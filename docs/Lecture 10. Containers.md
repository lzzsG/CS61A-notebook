---
layout: page
title: L10 Containers
permalink: /L10
description: "Lecture 10. Containers"
nav_order: 10




---

# Lecture 10. Containers

### CS61A - 课程公告与本周安排

1. **期中考试重评分申请截止时间**：期中考试1的重评分申请截止于**周一**。请确保你上传的期中考试录音链接在**周一**前仍然有效。如果需要更长时间保存，你将会收到通知。否则，你可以在**周二**之后删除它们，以释放Google Drive空间。

2. **作业与实验**：
   - **作业2**：作业2的截止时间是**周四**。请按时提交作业。
   - **实验**：本周有实验安排，实验在**周二**截止。建议大家在**周一**完成实验，如果有任何问题，可以参加**周一**的实验指导。
   
3. **完全可选的Hog策略竞赛**：
   - Hog策略竞赛将在**周一**结束。到目前为止，已经有112个提交。虽然目前有四名选手并列第一名，但往往会有同学在最后一刻提交最优的策略。
   - 欢迎大家继续参加，尽早提交可以查看你在竞赛排行榜中的排名情况。

4. **本周其他安排**：
   - **讨论课和辅导课**：将在**周三**进行。
   - **考试准备环节**：安排在**周五**，这将帮助大家复习并准备未来的考试。
   - **问答环节**：将在**周一、周三和周五**的早上进行，通过Zoom与授课教师进行交流。



### 本次课程内容概述

今天的课程将介绍如何给多个值命名，并使用容器将它们打包在一起。此外，还会讲解字符串的相关内容，因为它们本质上是包含字母的容器。

#### 列表（Lists）

1. **列表是Python中的内置数据类型**，用于存储一系列的值。可以通过列表字面量（list literals）创建列表，并使用赋值语句将列表绑定到变量名。
   - 示例：`odds = [1, 3, 5, 7]`
   - 通过索引来访问列表元素，索引从0开始：`odds[0]` 返回 `1`。
   
2. **获取列表长度**：
   - 使用 `len()` 函数：`len(odds)` 返回 `4`。

3. **列表操作**：
   - 通过 `+` 运算符可以将两个列表相加：`[1, 2] + [3, 4]` 返回 `[1, 2, 3, 4]`。
   - 使用 `*` 运算符可以重复列表中的元素：`[1, 2] * 2` 返回 `[1, 2, 1, 2]`。

4. **列表中的元素可以是任何数据类型**，包括其他列表。
   - 示例：`pairs = [[10, 20], [30, 40]]`，`pairs[1]` 返回 `[30, 40]`。

5. **测试元素是否在列表中**：
   - 使用 `in` 运算符检查元素是否在列表中，例如：`1 in odds` 返回 `True`，`5 not in odds` 返回 `False`。

6. **嵌套列表**：可以在列表中包含其他列表作为元素。

#### 小结

本次课程的重点在于列表的基本操作与应用，包括列表的创建、访问和操作。接下来的课程会进一步探讨递归以及容器的更多高级用法，例如字符串的处理。





在这段内容中，我们讨论了如何在Python中通过`for`语句遍历序列，并展示了如何利用它来简化代码逻辑。这种方法可以避免使用传统的`while`循环和手动管理索引，使代码更加简洁和易读。

### 重要内容总结：

1. **`in`操作符的用法**：
   - `in`操作符用于检查元素是否存在于序列中，但它只能检查**单个元素**，而不能检查子序列。
   - 示例：
     ```python
     digits = [1, 8, 2, 8]
     1 in digits   # True
     '1' in digits  # False (字符串'1'和整数1不同)
     [1, 8] in digits  # False (不能匹配子序列)
     ```
   - 如果列表中的元素本身是列表，`in`操作符可以检测列表是否包含另一个列表作为元素。
     ```python
     pairs = [[1, 2], [3, 4]]
     [1, 2] in pairs  # True
     ```

2. **`for`语句的作用**：
   - `for`语句是遍历序列的常用方法，它消除了手动管理索引的复杂性。
   - 通过`for`语句，可以简化代码，不再需要用`while`循环手动遍历和更新索引。
   - 示例：
     ```python
     def count(s, value):
         total = 0
         for element in s:
             if element == value:
                 total += 1
         return total
     ```
   - 在这个例子中，我们通过`for`语句遍历序列`s`中的每个元素，并计算序列中出现的`value`的次数。

3. **Python中的语法糖**：
   - `+=` 操作符是Python中的简写，等效于 `total = total + 1`。
   - 这种简化的操作符可以用于其他运算符，例如`-=`、`*=`等，便于简化代码。

4. **序列的解包**：
   - `for`语句的一个强大特性是可以在循环头部进行**序列解包**。
   - 例如，如果我们有一个包含元组的列表，我们可以在`for`循环中直接解包每个元组：
     ```python
     pairs = [(1, 2), (3, 4), (5, 5)]
     for x, y in pairs:
         if x == y:
             print(f"Pair ({x}, {y}) has identical elements.")
     ```

### 代码解析

使用`for`循环时，`for`语句的语法如下：
```python
for <name> in <expression>:
    <suite>
```
- `<expression>`需要是一个可迭代的对象（如列表、字符串等）。
- 每次循环，`<name>`会绑定到`<expression>`中的每个元素，随后执行`<suite>`中的代码块。

在执行过程中，Python会依次将`<expression>`中的元素赋值给`<name>`，并执行相应的操作。在`for`循环结束后，所有元素都被遍历。

### 序列操作的例子

考虑一个嵌套列表的情况，我们可以使用`for`循环和序列解包来简化对列表的处理：

```python
pairs = [[1, 2], [2, 2], [3, 4]]
for x, y in pairs:
    if x == y:
        print(f"Pair ({x}, {y}) has identical elements.")
```
在这个例子中，`x, y`会自动解包列表`pairs`中的每个子列表，并检查两个值是否相同。



通过这些例子，我们展示了如何有效使用`for`循环处理Python中的序列，这是一种常见而简洁的遍历方式。





在这段内容中，讨论了 Python 中的 `for` 循环以及其与序列相关的功能，特别是序列解包（sequence unpacking）和使用 `range` 对象进行循环控制。

### 重要内容总结：

1. **序列解包 (Sequence Unpacking)**:
   - 在 `for` 循环中，可以直接在循环头部解包序列，特别是在遍历固定长度的嵌套序列时。例如，遍历一个包含多个元组的列表时，可以将元组内的元素分别赋值给不同的变量：
     ```python
     pairs = [(1, 2), (2, 2), (3, 4), (4, 4)]
     same_count = 0
     for x, y in pairs:
         if x == y:
             same_count += 1
     print(same_count)  # 输出为 2，因为有两个元组 (2, 2) 和 (4, 4) 的元素相同
     ```
   - 这种方式简化了从复杂结构中提取元素的操作。

2. **`range()` 对象**:
   - `range()` 是一种序列类型，它不创建完整的列表，而是生成一个指定范围内的数字序列。
   - 重要特性：
     - `range(start, end)`：生成从 `start` 到 `end` （不包括 `end`）的数字序列。
     - 如果只提供一个参数，则表示从 0 开始到指定的结束位置，例如 `range(4)` 会生成 0 到 3 的数字。
     - `range()` 是懒加载的，不会立即生成所有数字。可以使用 `list()` 将其转换为列表来查看具体的数字。
     - 示例：
       ```python
       r = range(5, 8)  # 生成 [5, 6, 7]，但尚未实际生成
       print(list(r))   # 输出 [5, 6, 7]
       ```

3. **使用 `range` 在 `for` 循环中迭代**:
   - 常用于需要固定次数的循环，例如重复执行某个操作多次。
   - 例如，计算小于某个数字的整数的和：
     ```python
     def sum_below(n):
         total = 0
         for i in range(n):
             total += i
         return total
     print(sum_below(5))  # 输出 10（0 + 1 + 2 + 3 + 4）
     ```

4. **使用 `_` 作为占位符**:
   - 当在 `for` 循环中不关心循环变量时，通常用下划线 `_` 作为变量名，以表明不需要该变量。
   - 示例：
     ```python
     for _ in range(3):
         print("Go Bears!")
     ```
   - 输出结果为：
     ```
     Go Bears!
     Go Bears!
     Go Bears!
     ```

### 代码示例解析：

#### 序列解包示例
```python
pairs = [(1, 2), (2, 2), (3, 4), (4, 4)]
same_count = 0
for x, y in pairs:
    if x == y:
        same_count += 1
print(same_count)  # 输出为 2
```
- 解释：`pairs` 是一个包含元组的列表，每个元组有两个元素。`for x, y in pairs` 中，`x` 和 `y` 分别对应元组中的两个元素。在循环体内，通过比较 `x` 和 `y` 来判断是否相等，并计数。

#### `range()` 示例
```python
r = range(5, 8)
print(list(r))  # 输出 [5, 6, 7]

for i in range(4):
    print(i)  # 输出 0, 1, 2, 3
```
- 解释：`range(5, 8)` 生成了一个范围从 5 到 7 的 `range` 对象。使用 `list()` 可以将其转换为实际的列表。
- `range(4)` 生成 0 到 3 的数字序列，通过 `for` 循环依次输出每个数字。

#### 固定次数的重复操作示例
```python
for _ in range(3):
    print("Go Bears!")
```
- 解释：使用下划线 `_` 表示不关心循环中的变量，只是重复执行三次。



通过这些例子，可以更好地理解如何使用 Python 中的 `for` 循环和 `range()` 进行序列的迭代和操作，以及如何在循环中处理序列的解包等常见任务。这些特性使得编写简洁、可读性高的代码更加容易。





### 练习题讲解：求和的迭代与递归实现

#### 题目要求：
1. **编写一个迭代函数**，输入一个正整数 `n`，返回前 `n` 个整数的和。例如，`sum(5)` 应该返回 `1 + 2 + 3 + 4 + 5 = 15`。
2. **编写一个递归函数**，完成相同的任务：求前 `n` 个整数的和。



### 第一部分：迭代解法

首先，我们需要编写一个迭代函数来求前 `n` 个整数的和。我们可以使用 `for` 循环或 `while` 循环来遍历 1 到 `n` 之间的数字，并将它们相加。

#### 代码示例：
```python
def iterative_sum(n):
    total = 0
    for i in range(1, n + 1):
        total += i
    return total
```

#### 解释：
- `total` 初始化为 0，用来累加每次循环中的值。
- `for i in range(1, n + 1)` 表示从 1 到 `n` 之间遍历（包括 `n`），并在每次循环中将 `i` 加入 `total`。
- 最后返回 `total`，即前 `n` 个整数的和。

#### 测试：
```python
print(iterative_sum(5))  # 输出: 15
```



### 第二部分：递归解法

接下来，我们编写递归版本的函数。递归的思想是，将问题分解为更小的子问题。例如，`sum(n)` 可以表示为 `n + sum(n-1)`，直到 `n` 减小到 1 或 0 为止（基准情况）。

#### 代码示例：
```python
def recursive_sum(n):
    if n == 0:  # 基准情况
        return 0
    else:
        return n + recursive_sum(n - 1)  # 递归调用
```

#### 解释：
- 基本情况：如果 `n == 0`，返回 0，因为 0 前面的数字和为 0。
- 递归情况：将 `n` 加上 `sum(n-1)`，这会递归地求解更小的问题，直到到达基准情况。

#### 测试：
```python
print(recursive_sum(5))  # 输出: 15
```



### 递归过程分析：

让我们通过一个具体的例子来理解递归是如何运作的：

假设我们调用 `recursive_sum(5)`：

1. `recursive_sum(5)` 返回 `5 + recursive_sum(4)`
2. `recursive_sum(4)` 返回 `4 + recursive_sum(3)`
3. `recursive_sum(3)` 返回 `3 + recursive_sum(2)`
4. `recursive_sum(2)` 返回 `2 + recursive_sum(1)`
5. `recursive_sum(1)` 返回 `1 + recursive_sum(0)`
6. `recursive_sum(0)` 返回 `0` （基准情况）

然后函数返回的值会逐层返回，最终得到结果 `5 + 4 + 3 + 2 + 1 = 15`。



### 小结：

- **迭代解法**：通过 `for` 或 `while` 循环遍历数字，累加求和，代码相对直接。
- **递归解法**：通过将问题分解为更小的子问题，利用递归函数解决问题。需要确保定义清晰的基准情况，否则可能导致无限递归。

这两个方法展示了同一问题的不同解决方式。递归虽然在某些情况下更优雅，但迭代往往更易于理解和调试。





### 练习题解答：递归与迭代实现求和

#### 题目概述：
1. **任务一**：编写一个迭代函数 `iterative_sum(n)`，输入一个正整数 `n`，返回前 `n` 个整数的和。
2. **任务二**：编写一个递归函数 `recursive_sum(n)`，实现相同的功能。



### 迭代解法

在这个解法中，我们使用 `for` 循环来累加从 1 到 `n` 的整数。

#### 代码示例：
```python
def iterative_sum(n):
    total = 0  # 初始化总和为0
    for i in range(1, n + 1):  # 从1遍历到n（包括n）
        total += i  # 将每次循环的i累加到total中
    return total  # 返回累加后的总和
```

#### 解释：
- `total` 用来保存当前的累加值，初始值为 0。
- `for i in range(1, n + 1)` 会从 1 遍历到 `n`（包括 `n`），每次循环将 `i` 加入 `total`。
- 最后返回累加后的总和 `total`。

#### 测试：
```python
print(iterative_sum(5))  # 输出: 15
```

#### 结果分析：
`iterative_sum(5)` 将返回 `1 + 2 + 3 + 4 + 5 = 15`。



### 递归解法

递归版本通过递归调用来实现，递归的思想是将问题拆解为更小的子问题：`sum(n)` 可以表示为 `n + sum(n-1)`，直到 `n` 递减为 0（基准情况）。

#### 代码示例：
```python
def recursive_sum(n):
    if n == 0:  # 基准情况：n为0时返回0
        return 0
    else:  # 递归情况：n加上递归调用的结果
        return n + recursive_sum(n - 1)
```

#### 解释：
- 基本情况：如果 `n == 0`，直接返回 0，这是递归的终止条件。
- 递归情况：将当前 `n` 加上 `recursive_sum(n - 1)` 的结果，递归求解更小的问题，直到到达基准情况。

#### 测试：
```python
print(recursive_sum(5))  # 输出: 15
```

#### 递归过程分析：
假设我们调用 `recursive_sum(5)`，递归调用如下：
1. `recursive_sum(5)` 返回 `5 + recursive_sum(4)`
2. `recursive_sum(4)` 返回 `4 + recursive_sum(3)`
3. `recursive_sum(3)` 返回 `3 + recursive_sum(2)`
4. `recursive_sum(2)` 返回 `2 + recursive_sum(1)`
5. `recursive_sum(1)` 返回 `1 + recursive_sum(0)`
6. `recursive_sum(0)` 返回 0（基准情况）

最终，返回值逐层返回，直到得到最终结果：`5 + 4 + 3 + 2 + 1 = 15`。



### 小结

- **迭代解法**：通过 `for` 循环遍历数字并累加，非常直观。
- **递归解法**：通过将问题分解为更小的子问题，利用递归解决。需要确保定义清晰的基准情况。

这两种方法展示了同一个问题的不同解决方式。在很多情况下，递归虽然更优雅，但在处理简单问题时，迭代往往更容易理解且效率更高。





这是关于**字符串和列表推导式**的讲解，其中讨论了如何利用条件和表达式处理序列、字符串及其各种操作。以下是核心概念的详细讲解：

### 列表推导式 (List Comprehensions)
列表推导式是一种强大的工具，用于根据已有的序列创建新的列表。它的基本语法如下：

```python
[expression for element in iterable if condition]
```

- **expression** 是你希望应用于每个元素的操作，比如对每个元素进行某种运算。
- **element** 是从序列中提取的元素。
- **iterable** 是你要遍历的序列（比如列表、范围等）。
- **if condition** 是一个可选条件，只有满足条件的元素才会被包含到新的列表中。

#### 示例：
我们希望从 1 到 25 中找出所有能整除 25 的数，并返回这些数加 1 的结果：

```python
[x + 1 for x in range(1, 26) if 25 % x == 0]
```

- `range(1, 26)` 生成了 1 到 25 的序列。
- `25 % x == 0` 仅保留能整除 25 的数。
- `x + 1` 表示我们将每个符合条件的数加 1。

结果将会是 `[2, 6, 26]`，因为 1、5 和 25 是能整除 25 的数，加 1 后分别是 2、6 和 26。

### 函数中的列表推导式
列表推导式也可以用于函数中。例如，我们想要找出某个数 `n` 的所有因数，可以使用如下函数：

```python
def divisors(n):
    return [x for x in range(1, n + 1) if n % x == 0]
```

- `range(1, n + 1)` 生成 1 到 `n` 的序列。
- `if n % x == 0` 保留所有能整除 `n` 的数（即因数）。

#### 示例：
```python
print(divisors(12))  # 输出: [1, 2, 3, 4, 6, 12]
```

### 字符串
**字符串 (Strings)** 是一种抽象的数据表示形式，通常用于表示文本数据。字符串可以用单引号、双引号或三引号表示：

- **单引号和双引号**：单行字符串，可以包含字母、数字、符号等。例如 `'Hello'` 或 `"World"`。
- **三引号**：可以跨多行的字符串，常用于文档字符串（docstrings）。例如：

  ```python
  """This is a multi-line
  string in Python"""
  ```

### 字符串操作
1. **字符串是序列**：与列表相似，字符串也是一种序列类型。你可以使用 `len()` 获取字符串的长度，并使用索引操作来访问特定字符。
   
   ```python
   city = "Berkeley"
   print(len(city))  # 输出: 8
   print(city[0])  # 输出: 'B'
   print(city[7])  # 输出: 'y'
   ```

2. **字符串的元素是单个字符的字符串**：当你通过索引获取字符串的某个元素时，返回的仍然是一个长度为 1 的字符串，而不是单个字符。

3. **字符串中的 in 操作符**：不同于列表中仅检查元素是否存在，字符串的 `in` 可以检查子串。例如：
   
   ```python
   sentence = "Where's Waldo?"
   print("Waldo" in sentence)  # 输出: True
   print("123" in sentence)  # 输出: False
   ```

### 特殊字符与转义序列
- **转义序列**：通过反斜杠（`\`）对特殊字符进行转义。例如，`\n` 表示换行符，`\t` 表示制表符。
  
  ```python
  multiline_string = "Hello,\nWorld!"
  print(multiline_string)
  # 输出:
  # Hello,
  # World!
  ```

### 小结
- 列表推导式和字符串的基本操作是 Python 中常见的组合方法。
- 列表推导式提供了一种简洁高效的方式来生成新的列表，尤其是在涉及到过滤和条件时。
- 字符串是用于表示文本的基本数据类型，Python 中的字符串支持丰富的操作，例如索引、切片、查找子串等。





我们可以用递归的方式来实现字符串的反转。在递归过程中，我们会不断简化问题，直到遇到基准情况（base case），然后将结果组合起来返回。

### 字符串反转递归思路：
1. **基准情况**：
   - 如果字符串的长度为1或者是空字符串，那么直接返回该字符串即可，因为它已经是反转的结果。
   
2. **递归情况**：
   - 对于长度大于1的字符串，将第一个字符放到末尾，然后递归地反转剩下的子字符串。

### 递归反转字符串的Python实现：

```python
def reverse(s):
    # 基准情况：如果字符串长度为0或1，直接返回
    if len(s) <= 1:
        return s
    # 递归情况：反转剩下的字符串并将第一个字符移到末尾
    return reverse(s[1:]) + s[0]
```

### 代码解析：
- **基准情况**：`if len(s) <= 1:` 检查字符串的长度。如果字符串长度为0或1，直接返回它，因为它已经是反转的结果。
  
- **递归情况**：`return reverse(s[1:]) + s[0]` 将第一个字符 `s[0]` 放到末尾，并递归地反转剩余的字符串 `s[1:]`。

### 示例：
```python
print(reverse("ward"))  # 输出: draw
print(reverse("hello"))  # 输出: olleh
```

### 递归过程解析：
假设我们输入的是字符串 `"ward"`，递归的执行过程如下：
1. `reverse("ward")` 调用 `reverse("ard") + "w"`
2. `reverse("ard")` 调用 `reverse("rd") + "a"`
3. `reverse("rd")` 调用 `reverse("d") + "r"`
4. `reverse("d")` 返回 `"d"`（基准情况）
5. 返回值开始回溯：
   - `reverse("rd")` 结果为 `"dr"`
   - `reverse("ard")` 结果为 `"dra"`
   - `reverse("ward")` 结果为 `"draw"`

通过递归的方式，我们成功地将字符串 `"ward"` 反转为 `"draw"`。

这种方法展示了递归的核心思想：**简化问题、基准情况和递归组合**。与迭代算法不同，递归算法往往更直观，但在处理大规模问题时可能会面临递归深度限制或性能瓶颈。





在这个递归反转字符串的示例中，重点是要理解递归的思维方式，尤其是如何一步步简化问题，直到达到基准情况（base case）。让我们更深入地分析这个过程。

### Python 中实现字符串反转的递归代码：

```python
def reverse(s):
    # 基准情况1: 如果字符串为空
    if len(s) == 0:
        return s
    # 基准情况2: 如果字符串长度为1
    elif len(s) == 1:
        return s
    # 递归情况: 将第一个字符放到最后，递归反转剩下的字符串
    else:
        return reverse(s[1:]) + s[0]
```

### 代码详细说明：
1. **基准情况1**：如果传入的字符串为空（`len(s) == 0`），我们直接返回空字符串。这是为了处理特殊情况，比如用户可能会传入空字符串，避免程序崩溃。
   
2. **基准情况2**：当字符串只有一个字符时（`len(s) == 1`），直接返回该字符，因为反转一个字符的字符串还是它自己。

3. **递归情况**：对于任意长度大于1的字符串，递归过程如下：
   - 使用 `s[1:]` 获取除了第一个字符之外的子字符串，并递归地反转它。
   - 然后将第一个字符 `s[0]` 追加到反转后的子字符串的末尾。

### 递归过程的解释：
假设我们调用 `reverse("ward")`，递归过程如下：
1. `reverse("ward")` -> `reverse("ard") + "w"`
2. `reverse("ard")` -> `reverse("rd") + "a"`
3. `reverse("rd")` -> `reverse("d") + "r"`
4. `reverse("d")` -> `"d"`（基准情况）
5. 回溯开始：
   - `reverse("rd")` -> `"dr"`
   - `reverse("ard")` -> `"dra"`
   - `reverse("ward")` -> `"draw"`

通过递归，我们一步步将字符串缩小，直到到达基准情况，然后在回溯过程中逐步构建起反转后的字符串。

### 递归思维的关键：
递归的核心在于：**将复杂问题简化为更小的相同类型问题，并通过基准情况来终止递归**。在这个例子中，我们通过一次次递归调用，将字符串拆分成更小的部分，直到我们到达最简单的字符串形式（单个字符或空字符串）。

这和我们之前讨论的阶乘问题类似，都是通过递归调用逐步构建最终的结果。





