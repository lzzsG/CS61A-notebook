# Lecture 16. Mutable Functions

在这一讲中，我们探讨了一个重要的概念：**可变函数**。可变函数是与可变数据关联的函数，这些数据会随着时间的推移而发生变化。

### 可变函数的介绍

一个典型的例子是银行账户的模型，它通过一个 `withdraw`（取款）函数来实现。这个函数每次被调用时，会根据取款金额减少账户余额，并返回剩余的余额。

```python
def make_withdraw(balance):
    def withdraw(amount):
        nonlocal balance
        if amount > balance:
            return 'Insufficient funds'
        balance = balance - amount
        return balance
    return withdraw
```

#### 关键概念：
- **初始余额**：`make_withdraw` 函数接收初始余额作为参数，并创建一个 `withdraw` 函数，该函数能随着取款操作不断修改账户的余额。
- **`nonlocal` 声明**：为了在闭包中修改外层函数（`make_withdraw`）中的 `balance` 变量，必须使用 `nonlocal` 关键字。
  
#### 执行流程：
1. 调用 `make_withdraw(100)`，创建一个具有初始余额 100 的取款函数 `withdraw`。
2. 调用 `withdraw(25)`，减少余额并返回 75。
3. 再次调用 `withdraw(25)`，余额减少至 50。
4. 如果取款金额超出余额，例如 `withdraw(60)`，函数会返回 "Insufficient funds"（余额不足）。

通过这种方式，`withdraw` 函数模拟了一个随时间推移余额会发生变化的银行账户。

### 环境图与变量作用域

每次调用 `withdraw` 函数时，都会创建一个新的调用帧，但所有这些调用帧都会共享同一个父帧（`make_withdraw` 的帧），从而共享相同的余额。这个共享的余额正是通过 `nonlocal` 声明修改的。这种设计使得函数可以维护自己的状态，并在多个调用之间保持数据的连续性。

### 非本地赋值（`nonlocal`）

**`nonlocal` 赋值** 是 Python 提供的一种特殊机制，它允许在嵌套函数中修改外层函数的变量。普通的赋值只能作用于当前函数的局部变量，而使用 `nonlocal` 可以使函数修改其外层函数中的变量。这在需要维护跨函数调用的状态时尤为重要，例如银行账户余额的动态更新。

```python
nonlocal balance
```
- 这条语句告诉 Python，`balance` 变量并不是在当前函数中定义的，而是在外层函数中定义的，因此需要在外层作用域中进行查找并修改。

### 总结

通过本节内容，我们学习了如何使用闭包和 `nonlocal` 关键字来实现可变函数，这使得函数能够保存并修改跨调用的状态。在 Python 中，这一机制非常有用，可以用于实现像银行账户这样复杂的可变数据模型。







在这节课中，我们详细探讨了**非本地赋值（nonlocal assignment）**的概念，以及它在函数的作用范围（scope）中的使用。

### 非本地赋值的概念

在 Python 中，赋值语句通常只能修改当前作用域（frame）中的变量。然而，通过引入 **nonlocal** 关键字，我们可以在嵌套函数中修改外层函数的变量。nonlocal 允许函数访问并修改其父函数中的变量，而不仅仅是局部变量。

#### 示例：银行账户取款函数

```python
def make_withdraw(balance):
    def withdraw(amount):
        nonlocal balance
        if amount > balance:
            return 'Insufficient funds'
        balance = balance - amount
        return balance
    return withdraw
```

在这个例子中：
- `make_withdraw` 函数创建了一个初始余额，并返回一个 `withdraw` 函数。
- `withdraw` 函数使用 `nonlocal` 关键字来修改外层函数中的 `balance` 变量，从而实现每次取款时余额的减少。

#### 逻辑解析：
1. **定义余额**：`make_withdraw` 接收一个初始余额，并创建一个 `withdraw` 函数。`withdraw` 函数每次被调用时，会从余额中减去取款金额。
2. **nonlocal balance**：通过 `nonlocal balance` 声明，`withdraw` 函数能够修改 `make_withdraw` 中的 `balance`，而不是创建一个局部的 `balance`。
3. **返回余额**：`withdraw` 函数根据余额是否充足返回剩余余额，或提示"余额不足"。

### 环境图解释

环境图用于帮助我们理解变量在不同作用域中的绑定与修改：
1. 当 `make_withdraw` 被调用时，会创建一个新帧，`balance` 在该帧中绑定为初始余额。
2. 调用 `withdraw` 时，会创建一个新的帧，该帧的父帧是 `make_withdraw` 的帧。
3. `nonlocal balance` 使得 `withdraw` 可以修改父帧中的 `balance`，从而更新余额。
4. 余额的改变在父帧中生效，因此后续的 `withdraw` 调用将基于更新后的余额进行计算。

### 非本地赋值的规则

`nonlocal` 声明的规则如下：
- **作用范围**：`nonlocal` 声明允许在嵌套函数中修改外层函数中的变量。赋值会影响该变量在其**第一个非本地作用域**中的绑定。
- **约束**：
  - 声明的变量必须已经在外层作用域中定义过，不能在当前局部作用域中定义。
  - 如果变量在局部作用域中已有绑定，则不能使用 `nonlocal` 来修改。

### 多重赋值与限制

- 你可以在 `nonlocal` 语句中列出多个变量，例如 `nonlocal x, y`。
- 这些变量必须在外层作用域中存在，并且不能在当前作用域中已经绑定。

### 总结

非本地赋值是一种强大的机制，允许函数修改其外层作用域中的变量，进而实现持久的局部状态管理。通过 `nonlocal`，我们可以在闭包中维护状态，创建更加灵活和强大的函数，例如模拟银行账户余额随取款操作的变化。





在这节课中，我们探讨了 Python 中非本地赋值（nonlocal assignment）的使用规则以及实现可变函数的不同方法。通过对非本地赋值的深入讨论，了解如何在嵌套函数中管理局部状态，并讨论了非本地赋值和可变对象的区别。

### 非本地赋值的作用与规则

1. **非本地赋值的核心**：非本地赋值（nonlocal）允许嵌套函数修改外层函数中的变量。使用 `nonlocal` 声明后，修改将作用于最近的父函数中已绑定的变量，而不会创建新的局部变量。
   
2. **使用 nonlocal 的场景**：当我们希望在闭包中维护一个随时间变化的状态（如余额）时，`nonlocal` 使得我们能够修改外层函数的变量。例如，`make_withdraw` 函数返回一个 `withdraw` 函数，后者可以通过 `nonlocal` 访问并修改 `balance`。

3. **nonlocal 规则**：
   - nonlocal 语句要求该变量在非本地（外层）作用域中已经绑定。
   - 该变量不能在当前局部作用域中有绑定。
   - 如果试图对未在父作用域中绑定的变量使用 nonlocal，将抛出语法错误。

### 示例：银行账户取款函数

```python
def make_withdraw(balance):
    def withdraw(amount):
        nonlocal balance
        if amount > balance:
            return 'Insufficient funds'
        balance = balance - amount
        return balance
    return withdraw
```

在这个例子中：
- **make_withdraw** 创建一个取款函数，并初始化余额 `balance`。
- **withdraw** 函数通过 `nonlocal balance` 修改父函数中的 `balance`，从而实现余额的更新。
- 通过调用 `withdraw`，用户可以多次取款，余额会相应减少。

### 非本地赋值的语法错误

在 Python 中，非本地赋值有一些特定的语法规则。如果违反这些规则，可能会导致以下错误：
1. **未绑定的变量**：如果尝试对未在父作用域中绑定的变量使用 `nonlocal`，会抛出 `SyntaxError`，提示没有找到非本地绑定。
2. **局部变量冲突**：如果某个变量在局部作用域中已绑定，但仍然使用 `nonlocal`，则会抛出 `SyntaxError`，提示该变量是参数并且不能是非本地的。

### 替代方案：使用可变对象

除了使用 `nonlocal`，还可以通过引入可变对象来实现函数的局部状态持久化。由于列表是可变的，我们可以通过修改列表中的元素来维护函数的状态，而无需使用非本地赋值。

```python
def make_withdraw_list(balance):
    b = [balance]
    def withdraw(amount):
        if amount > b[0]:
            return 'Insufficient funds'
        b[0] = b[0] - amount
        return b[0]
    return withdraw
```

在这个版本中，我们将余额存储在一个列表 `b` 中。由于列表是可变的，`withdraw` 函数可以通过修改列表的元素来更新余额，而不需要使用 `nonlocal`。

### 环境图分析

当我们调用 `make_withdraw_list` 时，创建了一个新的列表 `b`，它包含了初始余额。每次调用 `withdraw` 时，都会修改列表 `b` 中的余额值。通过列表的可变性，我们实现了同样的效果，而无需非本地赋值。

### 总结

- **nonlocal**：用于修改外层函数中的局部变量，是一种实现局部状态持久化的方式。
- **可变对象**：通过可变对象（如列表）也可以实现局部状态的更新，避免了使用 `nonlocal` 的复杂性。
- **局部状态**：通过这些机制，可以在函数内部维护状态，使得函数的行为随时间而改变。这种技术在模拟银行账户等有状态的对象时非常有用。

了解这些概念，有助于编写更加复杂且灵活的 Python 程序。





在这一节中，我们深入探讨了可变函数中的局部状态，以及如何通过非本地赋值和可变对象来实现持久的局部状态。我们以银行账户的例子来说明不同函数如何共享或维护各自的状态，且如何避免相互影响。我们还讨论了 **引用透明性（referential transparency）** 的概念，以及如何通过赋值和环境的变化影响程序的行为。

### **局部状态与多个可变函数**

当有多个函数分别维护自己的局部状态时，它们各自的状态是独立的。我们通过一个例子来说明：

1. **两个独立的银行账户**：John 和 Steven 各自拥有一个独立的银行账户，John 有 $100，而 Steven 有 $100,000。
   - **John 和 Steven 的账户是分开的**：即便他们的余额偶然相同（比如都剩下 $50），他们的账户依然是不同的。
   - **每个账户的操作独立**：John 的取款操作不会影响 Steven 的账户余额，反之亦然。两者各自维护自己的局部状态。

### **引用透明性**

**引用透明性** 是指在一个程序中，如果用表达式的值替换该表达式，不会改变程序的行为。我们通过以下例子解释了这个概念：

- 当我们只有纯粹的函数调用（如加法、乘法）时，替换表达式为其计算结果不会影响程序的行为。例如，将 `mul(4, 6)` 替换为 `24`，再将 `add(2, 24)` 替换为 `26`，程序的结果依然保持一致。
- 然而，**可变操作破坏了引用透明性**。可变操作不仅返回值，还会修改程序的环境，这意味着替换一个表达式为其结果时可能会影响程序的后续执行。

### **引用透明性的丧失示例**

我们通过一个复杂的例子展示了如何通过非本地赋值导致引用透明性丧失：

```python
def f(x):
    x = 4
    def g(y):
        def h(z):
            nonlocal x
            x = x + 1
            return x + y + z
        return h
    return g

a = f(1)  # f(1) -> g
b = a(2)  # g(2) -> h
result_1 = b(3)  # 调用 h(3)，计算 x + y + z
result_2 = b(4)  # 再次调用 h(4)
```

#### 分析：

1. 调用 `f(1)`：创建一个局部变量 `x`，初始为 1，但被立即重设为 4。返回函数 `g` 并将其赋给 `a`。
2. 调用 `a(2)`：返回函数 `h`，将其赋给 `b`，此时 `y` 被设为 2。
3. **第一次调用 `b(3)`**：
   - `z = 3`，`nonlocal x` 的声明使得 `h` 函数可以修改外层函数 `f` 中的 `x`。
   - `x` 递增为 5，返回 `x + y + z = 5 + 2 + 3 = 10`。
4. **第二次调用 `b(4)`**：
   - `z = 4`，`x` 再次递增为 6，返回 `x + y + z = 6 + 2 + 4 = 12`。

通过这个例子，我们展示了如何通过非本地赋值改变外层函数中的局部变量，从而导致相同的函数调用返回不同的结果。这破坏了程序的引用透明性。

### **总结**

- **局部状态**：函数的局部状态可以通过 `nonlocal` 关键字或使用可变对象来维护。不同函数的局部状态相互独立，除非它们共享同一个可变对象。
- **引用透明性**：在没有可变操作的情况下，程序中的表达式可以被其值替换而不影响程序行为。可变操作（如 `nonlocal` 赋值）会改变程序的环境，导致引用透明性丧失。
- **可变函数与环境**：通过非本地赋值和闭包，函数可以维护随时间变化的状态。这为我们提供了强大的功能，但也带来了复杂性和潜在的错误。

在设计程序时，理解引用透明性和局部状态的影响对于编写稳定且可预测的代码非常重要。





在本次课程中，我们深入探讨了 **非本地赋值（non-local assignment）** 和 **引用透明性（referential transparency）** 的概念。我们通过详细的代码示例，演示了函数如何通过非本地赋值修改父作用域中的变量，以及如何在这种情况下丧失引用透明性。

### **非本地赋值的工作原理**
当我们在一个函数内使用 `nonlocal` 关键字时，表示这个函数可以修改其父作用域中的变量。通过非本地赋值，我们可以在不同的函数调用之间保持状态的变化，从而实现可变函数。

在例子中，我们有一个函数 `f`，它内部定义了另一个函数 `g`，`g` 返回函数 `h`。`h` 使用 `nonlocal` 修改了 `x` 的值：

```python
def f(x):
    x = 4
    def g(y):
        def h(z):
            nonlocal x
            x = x + 1
            return x + y + z
        return h
    return g
```

通过这个例子，我们展示了 `nonlocal` 如何影响外层函数中的变量 `x`。调用 `h` 函数时，`x` 的值被递增，并影响后续的函数调用。

### **丧失引用透明性的示例**
在没有引用透明性的情况下，相同的表达式在不同的时间可能会得到不同的结果。例如，当我们第一次调用 `b(3)` 时，`x` 被修改为 `5`，随后返回 `x + y + z` 的结果为 `10`。当我们再次调用 `b(4)` 时，`x` 被再次修改为 `6`，返回的结果为 `12`。

因此，总结果是 `10 + 12 = 22`。但是，如果我们用 `b(3)` 的值 `10` 直接替换表达式而不实际调用 `b(3)`，则 `x` 不会被第二次递增，导致总结果变成 `21`。这展示了由于函数的可变性，**引用透明性** 被破坏。

### **Tree Recursion 问题**
最后，课程推荐了一个递归问题 **Combo**，要求构建一个最小的整数，包含两个整数的所有数字。这个问题涉及 **树形递归** 的概念，需要通过递归寻找所有可能的组合，并选择最佳的解决方案。递归问题通常会有以下几个特点：
- **基准情况**：即简单到可以直接返回结果的情况。
- **递归情况**：需要通过递归调用来解决更复杂的问题。

### **总结**
- **非本地赋值（nonlocal）**：允许函数修改其父作用域中的变量，是实现持久局部状态的重要手段。
- **引用透明性**：当表达式的值依赖于环境的变化时，引用透明性会丧失。这意味着相同的表达式在不同的时刻可能会得到不同的结果。
- **树形递归**：当问题有多个选择路径时，通过树形递归可以枚举所有可能的解，找到最优解。

通过理解这些概念，学生可以更好地掌握可变函数的实现方式，以及如何在程序中有效地管理状态。



