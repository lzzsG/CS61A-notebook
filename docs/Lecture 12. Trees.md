---
layout: page
title: L12 Trees
permalink: /L12
description: "Lecture 12. Trees"
nav_order: 12






---

# Lecture 12. Trees

### 公告内容

1. **Cats 项目**：Cats 项目截止日期为下周五，但为了确保你按时完成，你需要在下周二前完成第一阶段，并获得检查点。如果你提前完成第一阶段，可以随时提交已完成的部分来获得该部分的分数。另外，如果你在下周四之前提交整个项目，可以获得一个额外的加分点。
   - **阶段划分**：
     - **第一阶段**：测量打字速度并选择打字内容。
     - **第二阶段**：构建自动纠错系统。
     - **第三阶段**：构建多人游戏模式。
   - 你可以提前在 [cats.cs61a.org](http://cats.cs61a.org) 上体验多人模式，系统会为你匹配其他正在尝试进行多人游戏的玩家。

2. **考试准备**：我们将在本周五下午 2:00 举行考试准备会议。此外，还有额外的问答环节，你可以在这里查看所有录音。

3. **Hog 策略比赛**：Hog 策略比赛结束了，恭喜所有参与者！这次比赛有超过 150 次提交，最后出现了五名并列第一的选手，分别是 Bobby Tables、匿名诗人、黄金比例、Wet App Program 和 Blockchain。每位并列第一的选手都表现出色，没有人能完全击败对方。

### 今天的内容：树结构

今天我们讨论的主题是**树（Trees）**。树是一种递归的数据结构，广泛应用于网站、组织架构、政府系统等具有层次结构的表示中。树结构是我们之前学习的容器和递归结合的体现，它能够帮助我们处理更复杂的数据层次。

**闭包性质**是树结构的核心。它指的是通过某种方法组合的数据，可以继续使用相同的方法组合。例如，列表可以包含其他列表作为元素，这种特性使得我们能够构建层次化的数据结构。在表示这些结构时，我们需要使用**方框和指针（Box and Pointer）**记法，帮助我们追踪哪些数据包含在另一个数据中。

- **Box and Pointer 记法**：这种记法用于在环境图中表示列表。当列表包含多个元素时，我们会用相邻的方框表示每个元素，并用指针指向其中的复合值。

### 列表示例

例如，假设我们有一个列表 `pair = [1, 2]`，我们可以在环境图中用两个相邻的方框来表示列表的两个元素，并给每个方框标上索引。

```python
pair = [1, 2]
```

环境图中的表示方式将如下：
- `pair` 绑定到一个包含两个元素 `1` 和 `2` 的列表。
- 每个元素的索引（从 0 开始）标记在对应的方框上。

通过树结构和递归，我们可以处理更加复杂的数据和逻辑，未来会在更多实际应用中看到树结构的重要性。





在这个例子中，我们继续讲解如何在 Python 中处理容器数据，特别是列表和字典的操作。在上一节中，我们通过“方框和指针”记法来表示复杂的数据结构，例如嵌套列表，并介绍了如何使用**切片操作符（Slicing Operator）**来选择列表的子集。

### 复杂列表的表示
当我们创建一个包含其他列表的嵌套列表时，比如 `nested_list = [[1, 2], [], [[3, False, None], func]]`，这会生成一个层次化结构。在“方框和指针”记法中，每个列表会指向其他列表（或是其他复合值），形成一个包含多个部分的树形结构。每个原始值（如整数、布尔值等）会直接显示在方框中，而每个函数或复杂值则会以箭头指向它们的具体表示。

### 列表切片
接下来，我们讨论了如何使用**切片**操作符来获取列表的子集。比如，假设我们有一个列表 `odds = [3, 5, 7, 9, 11]`，我们可以通过切片 `odds[1:3]` 来获取 `[5, 7]`。Python 的切片操作符的语法如下：

```python
list[start:end]
```
- `start`: 切片开始的索引（包含）。
- `end`: 切片结束的索引（不包含）。
  

例如，`odds[1:3]` 返回索引 1 和 2 的元素，但不包括索引 3。

- 如果我们省略 `start`，它会从列表的开头开始切片，例如 `odds[:3]` 返回 `[3, 5, 7]`。
- 如果省略 `end`，它会一直切到列表的结尾，例如 `odds[1:]` 返回 `[5, 7, 9, 11]`。
- `odds[:]` 返回整个列表 `[3, 5, 7, 9, 11]`。

切片操作每次都会生成新的列表，这意味着原始列表不会被修改。

### 序列聚合
在处理列表、字典等容器类型时，常常需要对其中的元素进行聚合操作。Python 内置了一些用于序列聚合的函数，使得这些操作更加高效。一个常见的例子是 `sum()` 函数，它可以对一个可迭代对象的元素求和：

```python
sum(iterable, start=0)
```

- `iterable`: 需要求和的序列。
- `start`: 起始值，默认为 0，但可以设置为其他类型的值。

例如：
```python
sum([2, 3, 4])  # 返回 9
```

如果我们想要对非数字元素（比如列表）进行操作，可以通过提供合适的起始值。例如：
```python
sum([[2, 3], [4]], start=[])  # 返回 [2, 3, 4]
```
这会把 `[2, 3]` 和 `[4]` 合并成一个列表 `[2, 3, 4]`。如果不提供起始值，程序会报错，因为无法将空列表与数字 0 相加。

总结来说，切片操作和序列聚合都是非常强大且常用的操作，尤其是在处理复杂的嵌套数据结构时。





我们现在进入了一个新的主题——**树（Tree）**，这是一种非常重要的数据抽象，用于表示层级关系。在计算机科学中，树通常“倒着生长”，即树的根部在顶部，叶子在底部。下面我们将讨论树的常见术语和结构。

### 树的基本概念
树的常见描述有两种：一种是递归描述，一种是家庭树的描述。

1. **递归描述**：树像一棵木头树（如苹果树），树由一个根节点（root label）和一系列分支（branches）组成。每个分支本身又是一棵树。这意味着，树的每个分支也有自己的根节点和可能的分支。如果一个树没有分支，我们称之为**叶子（leaf）**。因此，树的结构是递归的，可以通过树的根节点和分支来定义。

2. **家庭树描述**：树中的每个位置被称为**节点（node）**。根节点是位于树顶部的节点，而每个节点都有一个标签，标签可以存储任何值。通过这种方式，我们可以将树描述为一个层次结构，其中一个节点可以是另一个节点的**父节点（parent）**或**子节点（child）**。我们还可以描述祖先、后代和兄弟姐妹等关系。

### 树的实现
我们讨论了树的基本抽象——树由一个根标签和一系列分支组成，且每个分支必须是树。我们可以通过构造函数 `tree(root, branches)` 来创建树，并通过选择器 `root(tree)` 和 `branches(tree)` 来获取树的根节点和分支。

例如，下面的代码创建了一个简单的树结构：
```python
tree = [3, [1], [2, [1], [1]]]
```
该树的根节点是 `3`，有两个分支：一个是标签为 `1` 的子树，另一个是标签为 `2` 且包含两个子树（分别是标签为 `1` 的两个叶子）的子树。

在这种表示法中，树实际上是通过列表实现的，树的根节点是列表的第一个元素，而其分支是列表的后续元素。每个分支本身也是一个树（嵌套列表）。

### 树的基本操作
我们可以定义一系列函数来操作树。例如：

- **创建树**：`tree(root, branches)` 接受一个根节点值和一个分支列表，返回一个树结构。
- **获取根节点**：`root(tree)` 返回树的根节点。
- **获取分支**：`branches(tree)` 返回树的分支列表。

这些函数的作用是实现树的抽象，使得我们可以灵活地改变树的底层表示而不会影响其使用。

### 树的表示方式
树的底层表示可以用很多不同的方式实现，但在 Python 中，最常见的方式是用列表表示。例如，下面的代码创建了一个包含多个分支和子树的树：

```python
tree = [3, [1], [2, [1], [1]]]
```
这段代码的输出将是嵌套的列表，其中包含各个节点的标签和分支。在这个结构中，每个分支都是一个列表，它自身又包含其他分支或叶子。

### 树的操作例子
我们可以用递归的方式遍历或操作树。例如，要计算树中所有节点的总和，我们可以定义一个递归函数：

```python
def sum_tree(tree):
    return root(tree) + sum([sum_tree(b) for b in branches(tree)])
```

这个函数首先获取树的根节点值，然后递归地对每个分支调用自身函数，最后将结果相加。这种递归的方式充分利用了树的层次结构。

通过这种递归和抽象方法，我们可以方便地操作树形数据结构，实现复杂的数据处理和分析任务。





我们继续讨论树的抽象及其递归处理。

### 树的构造与递归处理

在上一部分，我们通过定义树的构造函数 `tree(label, branches)` 来构建树结构，其中 `label` 表示树的根节点值，`branches` 是树的分支列表。我们可以通过 `label(tree)` 获取根节点的值，`branches(tree)` 获取树的分支。

为了确保我们使用的结构是真正的树，我们引入了一些验证机制。例如，确保所有分支本身也是树，并通过递归检查每个分支是否满足树的定义。这可以通过递归函数 `is_tree` 来实现，它检查一个列表是否满足树的结构规则：即列表的第一个元素是根节点，而其余的元素都是分支树。

此外，树的递归操作非常重要。我们可以通过递归构造树，也可以递归地处理树。例如，下面是一个构造 Fibonacci 树的递归函数 `fib_tree`：

### Fibonacci 树的递归构造

Fibonacci 树是用递归方式生成的树，每个节点的值等于两个子节点的值之和。叶节点代表 Fibonacci 数列中的基本值 `F(0)` 或 `F(1)`。下面是 Fibonacci 树的构造函数：

```python
def fib_tree(n):
    """构造一个表示 Fibonacci 数列的树，根节点为 Fibonacci(n) 的值。"""
    if n <= 1:
        return tree(n)  # 基本情况：Fibonacci(0) 或 Fibonacci(1) 都是叶子
    else:
        left = fib_tree(n - 2)
        right = fib_tree(n - 1)
        return tree(label(left) + label(right), [left, right])  # 递归构造树
```

- 当 `n <= 1` 时，我们创建一个叶子节点，表示 Fibonacci 序列的基本值。
- 否则，我们递归构造左分支和右分支，分别代表 Fibonacci(n-2) 和 Fibonacci(n-1)。
- 最后，通过根节点值 `label(left) + label(right)` 和分支列表 `[left, right]` 构建一个新的树。

### 树的递归处理

在树的递归处理过程中，通常分为**基本情况**和**递归情况**。例如，我们可以写一个递归函数来统计树中的叶子节点数：

```python
def count_leaves(t):
    """统计树 t 中的叶子节点数。"""
    if is_leaf(t):
        return 1  # 如果是叶子节点，返回 1
    else:
        return sum([count_leaves(b) for b in branches(t)])  # 递归统计每个分支中的叶子节点
```

- **基本情况**：如果树 `t` 是叶子节点（通过 `is_leaf(t)` 检查），则返回 1，表示叶子节点的数量为 1。
- **递归情况**：对于每个分支 `b`，递归调用 `count_leaves(b)` 来统计子树中的叶子节点，并将结果相加。

通过这种递归方式，我们可以有效地处理树形结构，例如统计叶子节点、计算树中所有节点的总和、或者根据某些条件过滤节点。

### 树的递归与抽象的力量

使用树的递归和数据抽象，使得我们可以简洁地表示和处理复杂的层级数据结构。树的抽象不仅限于 Fibonacci 树，还可以用于表示各种结构化数据，例如公司组织结构、网页 DOM 树、或者目录文件系统。通过递归地构造和处理树形结构，我们能够高效地解决许多实际问题。

继续探索树的递归操作，将帮助我们更好地理解和应用数据抽象的强大功能。





### 树的递归处理：叶子计数、叶子标签收集与树的递归构造

在这一部分，我们将讨论如何递归处理树，包括计数叶子节点、收集叶子标签，以及通过树生成新树的过程。这些操作都是基于递归函数的实现。

#### 1. 叶子计数

在递归处理树时，**叶子节点**是处理的基本情况。如果我们想要计算树中叶子节点的数量，可以通过递归函数来实现。这个递归函数会对每个分支进行递归调用，最后将结果相加。

**实现叶子计数的代码**：
```python
def count_leaves(t):
    """计算树 t 中的叶子节点数量。"""
    if is_leaf(t):  # 基本情况：如果 t 是叶子，返回 1
        return 1
    else:
        # 递归情况：对每个分支递归调用 count_leaves，并将结果相加
        return sum([count_leaves(b) for b in branches(t)])
```

- **基本情况**：当树 `t` 是叶子节点时，返回 1。
- **递归情况**：对于每个分支 `b`，递归调用 `count_leaves(b)` 来计算子树中的叶子节点数，最后将所有分支的叶子数相加。

#### 2. 收集叶子标签

我们还可以编写一个函数，用来获取树中所有叶子节点的标签。这类似于叶子计数，但需要返回所有叶子的标签，而不仅仅是数量。为了实现这一点，我们可以递归收集每个分支中的叶子标签，并将它们合并成一个列表。

**实现收集叶子标签的代码**：
```python
def leaves(t):
    """返回树 t 中所有叶子的标签列表。"""
    if is_leaf(t):  # 基本情况：如果 t 是叶子，返回标签列表
        return [label(t)]
    else:
        # 递归情况：对每个分支递归调用 leaves，并使用 sum 合并结果
        return sum([leaves(b) for b in branches(t)], [])
```

- **基本情况**：当 `t` 是叶子节点时，返回一个包含其标签的列表。
- **递归情况**：对于每个分支 `b`，递归调用 `leaves(b)` 来获取子树的叶子标签，并通过 `sum` 函数将所有结果合并成一个列表。

`sum` 函数在这里用于展平列表，即将多个分支的结果合并成一个列表，而不是嵌套的列表。

#### 3. 生成新树（递增叶子节点）

我们还可以编写一个函数，用来生成一棵新的树，要求新树的叶子节点的标签值增加。例如，我们可以写一个函数 `increment_leaves`，它会递归地处理树中的叶子节点，并生成一个叶子标签值增加的新树。

**实现递增叶子标签的代码**：
```python
def increment_leaves(t):
    """返回树 t，但叶子节点的标签值增加 1。"""
    if is_leaf(t):  # 基本情况：叶子节点，标签值加 1
        return tree(label(t) + 1)
    else:
        # 递归情况：保持非叶子节点标签不变，递归处理分支
        return tree(label(t), [increment_leaves(b) for b in branches(t)])
```

- **基本情况**：如果 `t` 是叶子节点，则返回一个标签值加 1 的新叶子节点。
- **递归情况**：对于非叶子节点，保持根节点标签不变，递归处理分支，生成新分支。

#### 4. 递归处理所有节点

有时我们可能希望处理树中的每个节点，而不仅仅是叶子节点。例如，编写一个递归函数 `increment_t`，它会递增树中所有节点的标签。这里我们不需要单独处理叶子节点，而是对所有节点统一处理。

**实现递增所有节点标签的代码**：
```python
def increment_t(t):
    """返回树 t，但所有节点的标签值增加 1。"""
    # 返回一个新树，其中根节点的标签值加 1，所有分支也递归调用 increment_t
    return tree(label(t) + 1, [increment_t(b) for b in branches(t)])
```

- **递归处理所有节点**：这里没有显式的基本情况，因为递归终止自然发生在分支为空时。

#### 5. 打印树结构

最后，我们可以编写一个函数，用来打印树的结构，方便我们查看树的布局。这个函数可以递归地打印每个节点的标签，并递归调用分支来打印子树。

**实现树结构打印的代码**：
```python
def print_tree(t, indent=0):
    """打印树 t 的结构，缩进表示层级。"""
    print('  ' * indent + str(label(t)))  # 打印根节点标签
    for b in branches(t):
        print_tree(b, indent + 1)  # 递归打印子树
```

- **缩进打印**：`indent` 参数用于控制缩进，表示树的层级结构。
- **递归打印**：对每个分支调用 `print_tree`，逐层打印树的结构。

### 总结

我们通过递归函数来处理树，包括计算叶子节点、收集叶子标签、递增节点标签等操作。递归处理树的强大之处在于，我们可以用统一的方式处理复杂的树形结构，而不需要关心树的具体层次或节点数。通过这些例子，我们能够更好地理解递归在数据结构处理中的应用。





### 树的递归处理：打印路径和标签求和

这部分我们将实现一个递归函数，处理树的叶子节点，沿着从根到叶子的路径累加标签值，并打印出每条路径的标签和。我们也会探讨递归过程中传递参数和构造结果的两种不同策略。

#### 1. 递归构建树的路径和

我们的目标是：给定一棵树，对于每个叶子节点，计算从根到该叶子节点的标签和，并将该和打印出来。为了实现这个功能，我们需要递归遍历树，并在遍历过程中将路径上的标签累加。

##### 实现思路：

- 递归过程中，我们不仅需要知道当前节点的标签，还需要记录从根节点到当前节点为止的累积和。这样，当递归到达叶子节点时，我们就能够输出这条路径的标签和。
- 为了做到这一点，我们可以在递归函数中添加一个额外的参数，记录**当前累积的标签和**。随着递归深入，这个累积和逐步增加，直到我们到达叶子节点并打印它。

#### 2. 树的路径和递归函数

下面是实现该递归函数的代码：

```python
def print_sums(t, so_far):
    """递归遍历树 t，打印从根到叶子的标签和。"""
    # 更新当前路径的累积和
    so_far += label(t)
    
    # 基本情况：如果是叶子节点，打印累积的标签和
    if is_leaf(t):
        print(so_far)
    else:
        # 递归处理每个分支
        for b in branches(t):
            print_sums(b, so_far)
```

##### 代码解释：

- **累积和的更新**：在每次递归调用中，都会将当前节点的标签 `label(t)` 添加到累积和 `so_far` 上。
- **基本情况**：如果当前节点是叶子节点，则打印累积和。叶子节点的判断通过 `is_leaf(t)` 实现。
- **递归处理**：如果当前节点不是叶子节点，则递归处理它的每个分支，并将更新后的 `so_far` 传递给下一层递归。

#### 3. 样例树的构建

让我们定义一棵数字树，并调用 `print_sums` 函数：

```python
# 树的构建函数，树的表示形式为列表
def tree(label, branches=[]):
    return [label] + list(branches)

def label(tree):
    return tree[0]

def branches(tree):
    return tree[1:]

def is_leaf(tree):
    return not branches(tree)

# 构建样例树
numbers = tree(3, [tree(4), tree(5, [tree(6)])])

# 打印路径和
print_sums(numbers, 0)
```

这棵树的结构是：
```
    3
   / \
  4   5
       \
        6
```

- 从根 `3` 到叶子 `4` 的路径和为 `3 + 4 = 7`。
- 从根 `3` 到叶子 `6` 的路径和为 `3 + 5 + 6 = 14`。

输出结果应该是：
```
7
14
```

#### 4. 处理字符树

我们还可以处理包含字符串标签的树。例如，构建一个字母树并打印从根到叶子的标签串：

```python
# 构建字符树
haste = tree('H', [tree('A', [tree('S'), tree('T')]), tree('E')])

# 打印从根到叶子的路径标签串
print_sums(haste, "")
```

这棵树的结构是：
```
    H
   / \
  A   E
 / \
S   T
```

输出结果应该是：
```
HAS
HAT
HE
```

在处理字符串时，`so_far` 是一个累积的字符串，每次递归时将当前节点的标签追加到 `so_far` 中。

#### 5. 递归策略的比较

我们探讨了两种递归策略：
- **基于返回值的递归**：像计算阶乘的递归函数那样，依赖于递归调用的返回值来逐步构建最终结果。在树的情况下，这种策略常用于返回处理后的树或叶子节点集合。
- **基于参数传递的递归**：像 `print_sums` 这样的函数，通过将中间结果（如累积和或累积的标签串）作为参数传递给下一层递归。在到达递归的基本情况时，直接使用这个中间结果。

这两种策略在不同场景下都有用武之地，尤其是处理树等递归数据结构时，基于参数传递的递归方法非常高效且易于理解。

### 总结

通过本次讨论，我们展示了如何递归处理树的结构，特别是如何计算从根到叶子的路径和，以及如何通过递归传递中间结果来简化代码。这种递归模式在复杂数据结构的处理中十分有用，并且可以帮助我们更好地理解递归的威力和灵活性。

