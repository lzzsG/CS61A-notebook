# Lecture 15. Mutable Values

### 课程公告

- **项目截止日期**：猫科项目（Cats Project）将在星期五截止，今天（星期四）提交整个项目可以获得额外的加分。
- **作业发布**：第三次作业将在星期五发布，截止日期是下周四。
- **学术指导预约**：可以在星期五、星期六和星期一预约学术指导，这些预约只提供学术咨询，不包括作业或项目帮助。
- **办公室时间排队问题**：近期，办公室时间的排队时间较长。可以通过 Piazza 私密帖子提问，虽然不会立即得到回复，但我们会尽快解答。此外，学生之间也可以通过讨论组讨论代码和问题，但请注意不能与尚未完成问题的同学分享完整代码。

---

### 课程内容：**对象与可变性**

今天，我们将介绍一个非常重要的编程概念——**可变性（Mutation）**。这是课程中首次涉及值的变化。可变性是**面向对象编程（Object-Oriented Programming，OOP）**的核心之一。

#### 对象的基本概念

在软件工程中，**对象（Object）**是一个行为像其所表示值的实体。对象可以通过其**属性（Attribute）**和**方法（Method）**来表现行为。

**示例**：在 Python 中，我们可以使用 `datetime` 模块来处理日期和时间。

```python
from datetime import date

today = date(2015, 2, 20)  # 创建一个日期对象
freedom = date(2015, 5, 12)  # 创建另一个日期对象
```

在这里，`date` 是一个类，我们通过调用类创建了具体的实例（对象）。

#### 对象的行为

对象通过其属性和方法来表现行为。例如，我们可以通过**点表达式（dot expression）**访问日期对象的属性，例如年、月和日。

```python
today.year  # 获取年份
today.month  # 获取月份
```

这些属性告诉我们这个日期的年份和月份，且点表达式也可以用来访问对象的方法。

#### 方法示例

对象的方法是绑定到对象的函数。我们可以调用日期对象的 `strftime` 方法来将日期格式化为字符串。

```python
today.strftime('%A %B %d')
# 输出: 'Friday February 20'
```

这里，`%A` 对应星期几，`%B` 对应月份名称，`%d` 对应日期数字。通过这种方式，我们可以灵活地将日期对象转换为所需的字符串格式。

#### 面向对象编程

对象将**数据**和**行为**组合在一起，形成了强大的**抽象（Abstraction）**。一个类（Class）定义了对象的类型，而对象则是这个类型的实例。

面向对象编程（OOP）是一种主流的编程范式，通过将数据和操作打包到对象中，便于管理复杂程序。

接下来，我们将更深入地探讨面向对象编程，并介绍可变性的概念。





### 对象和类的概念

在面向对象编程中，**对象** 是用于组织和管理复杂程序的一种重要抽象。对象不仅可以表示事物，还可以表示事物的属性、交互或过程。每个对象都具有**属性** 和**方法**，可以对其进行操作。

- **类（Class）**：对象的类型称为类。类是 Python 中的**一等公民**，可以作为参数传递给函数。
- **对象与方法**：每个对象都可以通过**点表达式**访问其属性或方法。例如，日期对象 `today` 可以通过 `today.year` 访问其年份，`today.strftime()` 格式化日期为字符串。

在面向对象编程中，大型程序可以被认为是多个对象的集合，这些对象通过**消息传递**相互通信。Python 中的每个值都是对象，包括数字和字符串。

#### 函数与对象的区别

- **函数**：通常用于执行单一任务。函数接受参数，返回值，专注于特定的操作。
- **对象**：表示一个实体或概念，包含多个相关行为（方法）。例如，`date` 对象不仅可以代表日期，还能执行与日期相关的操作，如格式化、计算时间差等。

#### 字符串对象的示例

字符串是 Python 中的对象，因此也有自己的方法。例如：

```python
s = "hello"
s.upper()  # 返回 'HELLO'
s.lower()  # 返回 'hello'
s.swapcase()  # 返回 'HELLO'
```

这些方法都不会改变原始字符串，而是返回一个新的字符串。

### ASCII 和 Unicode

在表示字符串时，Python 使用 **ASCII** 和 **Unicode** 编码。了解这两种编码对于理解字符处理非常重要。

#### ASCII 编码

ASCII 是**美国信息交换标准代码**，最早用于计算机字符编码。它将字符映射为数字，分为8行和16列。每个字符都可以用数字表示。

- **示例**：字母 `A` 的 ASCII 编码是 65（十六进制是 41），可以在 ASCII 表中找到它在第4行第1列的位置。

ASCII 编码的一些控制字符在早期计算机通信中有特殊作用，例如 `LF`（换行）和 `BEL`（响铃）。

#### Unicode 编码

**Unicode** 设计用于支持全球所有语言的字符编码。Unicode 为每个字符分配一个**码点（code point）**，以便在不同的计算机系统和编程语言中统一处理字符。

- Unicode 目前包含超过 109,000 个字符，覆盖 93 种不同的书写系统。它不仅包括字符的编码，还支持双向显示（如英语从左到右、阿拉伯语从右到左）等特性。

你可以使用 Python 的 `unicode-data` 模块来查看 Unicode 字符的名称：

```python
from unicodedata import name, lookup

name('A')  # 输出 'LATIN CAPITAL LETTER A'
lookup('LATIN CAPITAL LETTER A')  # 返回 'A'
```

### 总结

- **对象** 通过属性和方法表现行为，是面向对象编程的核心概念。
- **ASCII** 和 **Unicode** 提供了表示字符的标准编码，确保不同语言和字符系统的兼容性。



### Unicode 字符的多样性

在 Unicode 编码中，字符不仅包括字母和数字，还包括许多不同的图形符号，比如笑脸、雪人、足球等。这些字符在不同的操作系统和字体下可能显示不同，但它们的编码是统一的。例如：

- 笑脸😊
- 雪人☃
- 足球⚽
- 婴儿👶

不同平台上显示的符号可能会有所不同，但这些字符背后的编码和概念在不同编程语言中是一致的。通过 `unicodedata` 模块，可以查看字符的名称：

```python
from unicodedata import name, lookup

name('😊')  # 输出 'SMILING FACE WITH SMILING EYES'
lookup('SMILING FACE WITH SMILING EYES')  # 返回 '😊'
```

即使符号的显示效果因平台或字体不同而变化，但它们的编码表示在计算机间是通用的。例如，字符“婴儿👶”可以被编码为一组字节。

### 对象的可变性（Mutation）

Python 中的对象可以**变异**，即对象的值可以随着时间发生变化。尤其是**列表（lists）**和**字典（dictionaries）**等可变类型，允许修改其内容，而不可变对象（如字符串、元组）一旦创建则无法更改。

#### 列表的可变性

例如，以下操作演示了如何修改列表内容：

```python
suits = ['coin', 'string', 'myriad']
suits.pop()  # 移除并返回列表的最后一个元素，返回 'myriad'
suits.append('club')  # 在列表末尾添加一个元素
suits.extend(['sword', 'cup'])  # 扩展列表，添加多个元素
```

当你对 `suits` 进行修改时，绑定到同一个对象的其他变量也会反映出这些变化。这说明了对象的可变性。

#### 字典的可变性

类似地，字典也可以修改其键值对：

```python
numerals = {'I': 1, 'V': 5, 'X': 10}
numerals['X'] = 11  # 修改字典中键 'X' 的值
numerals['L'] = 50  # 添加新的键值对 'L': 50
numerals.pop('X')  # 移除键 'X'，返回 11
```

修改字典后，访问相同键时返回的值会发生变化，这就是字典的可变性。

### 共享引用与对象变异

多个变量可以指向同一个对象，当该对象发生变化时，所有变量都能反映这些变化：

```python
list1 = [1, 2, 3]
list2 = list1
list1.append(4)
print(list2)  # 输出 [1, 2, 3, 4]
```

在这个例子中，`list1` 和 `list2` 指向同一个列表对象，因此对 `list1` 的修改也会影响 `list2`。

### 结论

- 可变对象（如列表和字典）允许修改内容，称为**变异**。
- 通过多个引用指向同一对象，修改该对象会影响所有引用。
- Unicode 提供了一套通用的字符编码，允许在不同语言和平台间表示字符。





### Python中的对象与变异（Mutation）

在Python中，对象不仅仅可以表示值，还可以发生**变异**，即对象的值可以随时间发生变化。这种变化尤其常见于**可变对象**（如列表和字典）。在本节课中，我们探讨了对象的变异以及如何在函数调用中更改对象的值。

#### 字典的变异

字典（dictionary）是可变的对象，这意味着你可以更改它的内容。例如：

```python
numerals = {'I': 1, 'V': 5, 'X': 10}
numerals['X'] = 11  # 修改字典中键 'X' 的值为 11
numerals['L'] = 50  # 添加新的键值对 'L': 50
numerals.pop('X')   # 移除键 'X'，返回 11
```

在这个例子中，我们通过赋值语句和 `pop()` 方法修改了字典 `numerals` 的内容。字典中的键值对可以被添加、更新或删除。

#### 列表的变异

类似地，列表（list）是可变的，意味着列表中的元素可以被修改。例如：

```python
lst = [1, 2, 3, 4]
lst.pop()   # 移除最后一个元素，返回 4
lst.append(5)  # 在列表末尾添加元素 5
```

如果你传递一个列表给函数，函数可以直接修改该列表的内容，因为列表是可变的。

```python
def mystery(s):
    s.pop()
    s.pop()

lst = [1, 2, 3, 4]
mystery(lst)
print(lst)  # 输出 [1, 2]
```

在这个例子中，函数 `mystery` 修改了传入的列表对象 `lst`。由于列表是可变的，函数对 `s` 的修改会影响到外部的 `lst`。

#### 函数中的变异

函数可以改变其作用域内的任何可变对象。如果对象在全局作用域中，函数也可以直接访问并修改它。例如：

```python
lst = [1, 2, 3, 4]

def change_global_list():
    lst.pop()
    lst.pop()

change_global_list()
print(lst)  # 输出 [1, 2]
```

在这个例子中，`lst` 是一个全局变量，函数 `change_global_list` 可以直接访问和修改它。通过 `pop()` 函数移除了列表的最后两个元素。

#### 元组的不可变性

与列表和字典不同，**元组（tuple）**是不可变的。一旦创建，元组中的值就不能被改变：

```python
tup = (1, 2, 3)
# tup[0] = 5  # 错误，不能修改元组中的值
```

元组中的值是固定的，不能被修改。这意味着你可以将元组作为字典的键，而列表不能作为字典的键，因为列表是可变的。

```python
# 可以使用元组作为字典的键
coordinates = {(1, 2): "Point A", (3, 4): "Point B"}
```

虽然元组本身是不可变的，但如果元组包含可变对象（如列表），则这些可变对象仍然可以改变：

```python
tup = (1, 2, [3, 4])
tup[2].append(5)  # 可以修改元组中的列表
print(tup)  # 输出 (1, 2, [3, 4, 5])
```

#### 总结

- **可变对象**（如列表和字典）可以在函数内被修改。
- **不可变对象**（如元组和字符串）不能修改其内容，但如果元组包含可变对象，这些对象仍然可以被修改。
- 函数可以通过引用修改全局作用域中的可变对象。

对象的可变性为我们在编程中管理复杂数据结构提供了灵活性，同时也要求我们在修改对象时小心处理，以避免意外的副作用。







### Python中的对象身份与变异

在编程中，理解对象的身份和变异性是至关重要的。对象不仅有值，还拥有**身份**，即使其值发生了改变，它仍然是同一个对象。本节课详细讨论了对象的身份与值的区别，以及变异（Mutation）如何影响对象。

#### 对象的身份与相等性

对象可以有相同的值，但不一定具有相同的身份。理解相等性（equality）和**身份**（identity）的区别十分重要：

- **相等性**：两个对象的值相等时，它们被认为是相等的。
- **身份**：如果两个对象是同一个对象，即它们在内存中占用相同的位置，那么它们具有相同的身份。

例如：

```python
a = [10]
b = a  # a 和 b 指向同一个列表
a.append(20)
print(a)  # 输出 [10, 20]
print(b)  # 输出 [10, 20]，b 也会发生变化，因为它与 a 是同一个对象
```

在这个例子中，`a` 和 `b` 都指向相同的列表对象，改变 `a` 也会反映在 `b` 上，因为它们拥有相同的身份。

相反，如果它们只是具有相同的值但不是同一个对象：

```python
a = [10]
b = [10]  # a 和 b 是不同的对象，尽管它们有相同的值
print(a == b)  # True，值相等
print(a is b)  # False，它们不是同一个对象
```

#### 使用 `is` 和 `is not` 进行身份比较

在Python中，可以使用 `is` 运算符来检查两个对象是否具有相同的身份，而 `==` 运算符用于比较两个对象的值是否相等：

- `x is y`：如果 `x` 和 `y` 是同一个对象，则返回 `True`。
- `x == y`：如果 `x` 和 `y` 的值相等，则返回 `True`。

例如：

```python
a = [10]
b = [10]
print(a is b)  # False，a 和 b 是不同的对象
print(a == b)  # True，a 和 b 的值相等
```

#### 可变对象与不可变对象

在Python中，**可变对象**（如列表、字典）可以在其原有位置改变其内容，而**不可变对象**（如元组、字符串）一旦创建，其内容就不能改变。

```python
# 可变对象
lst = [1, 2, 3]
lst.append(4)  # 列表的内容被修改为 [1, 2, 3, 4]

# 不可变对象
tup = (1, 2, 3)
# tup[0] = 5  # 错误，元组是不可变的，无法修改其中的元素
```

但是，即使元组是不可变的，如果元组中包含可变对象（如列表），则可以修改这些可变对象：

```python
tup = (1, [2, 3])
tup[1].append(4)  # 修改元组中的列表，tup 变为 (1, [2, 3, 4])
```

#### 变异中的危险：默认参数

默认参数在函数定义时只被计算一次，后续函数调用如果对默认参数进行变异操作，这些变动会影响后续调用。来看一个例子：

```python
def append_five(s=[]):
    s.append(5)
    return len(s)

print(append_five())  # 输出 1
print(append_five())  # 输出 2，列表 `s` 是在上次调用时修改过的同一个列表
```

这里，默认参数 `s` 是一个可变的列表对象，调用函数时对其进行了修改，修改后的列表在下次调用时依然存在。因此，避免使用可变对象作为默认参数的一种方式是使用 `None` 作为默认值：

```python
def append_five(s=None):
    if s is None:
        s = []
    s.append(5)
    return len(s)
```

#### 复习：对象变异和环境图

对象的变异可以通过环境图来跟踪。环境图帮助我们理解变量在内存中的引用关系，尤其在涉及多个变量绑定到同一对象时尤为重要。

例如：

```python
s = [2, 3]
t = [5, 6]
s.append(t)
```

此时，`s` 的内容变为 `[2, 3, [5, 6]]`，列表 `t` 作为一个整体被添加到了 `s` 中。理解这种嵌套结构中的变异对编写和调试代码至关重要。

---

通过对象的身份与变异，我们可以更好地理解如何管理和操作复杂数据结构，以及如何在编程中处理对象的状态变化。







在这一讲中，我们深入探讨了列表的变异性以及如何通过操作改变列表的内容。通过一系列的代码示例和环境图的展示，我们学习了如何在 Python 中使用各种列表操作，如 `append`、`extend`、`slice assignment` 等来改变列表的内容和结构。

### 列表的变异操作及其效果

#### 1. **`append()` 操作**：
`append()` 向列表的末尾添加一个元素。

```python
s = [2, 3]
t = [5, 6]
s.append(t)
# s = [2, 3, [5, 6]]
```
- 这里 `append` 操作将整个列表 `t` 作为一个元素添加到 `s` 中。此时，`s` 变为一个包含三个元素的列表：`2`, `3` 和 `[5, 6]`。需要注意的是，`s` 中的最后一个元素是指向 `[5, 6]` 的引用，而不是将 `t` 本身复制进去。

#### 2. **`extend()` 操作**：
`extend()` 将一个列表的所有元素逐个添加到另一个列表中。

```python
s = [2, 3]
t = [5, 6]
s.extend(t)
# s = [2, 3, 5, 6]
```
- `extend()` 不会像 `append()` 那样添加一个嵌套的列表，而是将 `t` 中的所有元素平铺到 `s` 的末尾。

#### 3. **列表相加与切片**：
列表相加 (`+`) 会创建一个新列表，并且切片操作也会创建新列表。

```python
s = [2, 3]
t = [5, 6]
a = s + [t]
# a = [2, 3, [5, 6]]
```
- 这段代码将 `s` 和 `[t]` 相加，生成一个新列表 `a`，其中包含 `s` 的元素以及 `t` 作为一个嵌套列表。

```python
b = a[1:]  # 切片操作
# b = [3, [5, 6]]
```
- 切片操作生成一个新的列表 `b`，它包含 `a` 从索引 1 开始的元素。`b` 中的 `[5, 6]` 依然是对原始列表的引用。

#### 4. **切片赋值**：
通过切片赋值可以替换列表中的部分内容。

```python
s = [2, 3]
t = [5, 6]
s[0:0] = t
# s = [5, 6, 2, 3]
```
- `s[0:0] = t` 将 `t` 的元素插入 `s` 的起始位置，`s` 的其余部分右移。

```python
s[1:] = [7]
# s = [5, 7]
```
- 切片赋值 `s[1:] = [7]` 将 `s` 的索引 1 及以后的元素替换为 `[7]`，缩减了列表的长度。

#### 5. **`pop()` 和 `remove()`**：
- **`pop()`** 删除并返回列表的最后一个元素。
  
  ```python
  s = [2, 3]
  x = s.pop()
  # s = [2], x = 3
  ```
  `pop()` 操作将列表 `s` 的最后一个元素 `3` 删除，并返回这个值。
  
- **`remove()`** 删除列表中首次出现的指定元素。

  ```python
  s = [5, 6, 5, 6]
  s.remove(5)
  # s = [6, 5, 6]
  ```
  `remove(5)` 删除列表中第一个 `5`。

### 循环引用与递归列表

在列表中可以创建自引用结构，使得列表包含自身的引用：

```python
t = [1, 2, 3]
t[1:3] = [t]
# t = [1, [1, 2, 3]]
```
- 这段代码通过切片赋值让 `t` 的部分元素变成其自身的引用，从而创建了一个递归列表结构。

```python
t.extend(t)
# t = [1, [1, 2, 3], 1, [1, 2, 3]]
```
- `extend()` 操作会将 `t` 的所有元素，包括自身的引用，追加到列表末尾，导致列表递归地包含自身。

### 总结

通过本节的学习，我们深入了解了列表的各种变异操作及其在 Python 环境中的效果。这些操作展示了列表在 Python 中的强大灵活性以及操作时的注意事项，比如如何管理列表中的嵌套引用，以及理解变量如何绑定到相同的对象上。





