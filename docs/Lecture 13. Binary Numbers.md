---
layout: page
title: L13 Binary Numbers
permalink: /L13
description: "Lecture 13. Binary Numbers"
nav_order: 13







---

# Lecture 13. Binary Numbers

### 课程通知和内容概要

1. **项目截止日期**：
   - **CATS 项目**的截止日期是**周五**。
   - **第一阶段**的任务需要在**周二**之前完成，以获得**检查点的 1 分**。
   - 如果你能在**周四**之前提交整个项目，可以获得**提前提交的额外加分**。

2. **课堂讲座**：
   - **今天和周三的讲座**不会出现在考试或作业中，但内容非常有趣，值得学习。这些知识将在未来的课程中再次出现，现在的学习将有助于加深你对计算机如何表示程序的理解。

### 课程内容概述

3. **抽象的力量**：
   - 这学期的大部分时间我们都在讨论 Python 数据结构、算法、类和面向对象编程。其中一个重要的主题是**抽象**的力量。
   - 抽象可以帮助我们将复杂的数据或代码进行模块化处理，使得我们不需要关注底层细节，从而更加高效地编写代码。

4. **计算机作为终极抽象**：
   - 计算机本身就是一种极强的抽象工具。我们日常使用计算机进行各种操作，如保存文件或进行数值计算，但我们通常并不知道计算机的内部工作机制。
   - 在接下来的课程中，我们将探讨计算机的**基本构建模块**，并了解现代计算机的工作原理。

### 计算机的基础：二进制数与进制转换

5. **十进制数的复习**：
   - 我们日常使用的数字是**十进制**，这意味着每个数字的位数是基于 10 的幂次。例如，数字 723 可以表示为：
     \[
     7 \times 10^2 + 2 \times 10^1 + 3 \times 10^0
     \]
   - 每个数字在相应的位数上表示为该位数的数值乘以 10 的幂。

6. **进制的多样性**：
   - 虽然我们默认使用十进制，但其他进制系统在历史上也被广泛使用。例如，有些文明使用**八进制**（Base-8）。
   - 例如，八进制的 257 表示为：
     \[
     2 \times 8^2 + 5 \times 8^1 + 7 \times 8^0
     \]
   - 在这里，基数是 8，而不是 10。

### 课程目标

7. **理解现代计算机的核心构造**：
   - 在接下来的课程中，我们将逐步了解**现代计算机的基本构建块**，如二进制数和逻辑运算。
   - 尽管我们不会深入探讨所有复杂的细节，但你将学到足够的知识，以理解计算机如何执行从简单加法到复杂程序的各种计算。

### 结论

- **抽象和进制系统**是理解计算机工作原理的基础。通过理解不同的进制系统和二进制表示法，我们可以更好地理解计算机如何执行基本计算。
- 这些知识不仅对你现在的学习有帮助，还将在未来的课程中为你打下坚实的基础。



在这个内容中，讲者介绍了进制转换的基本原理，尤其是从非十进制（如八进制、二进制）转换到十进制的计算过程，并解释了不同进制系统的任意性。以下是讲解的详细整理和扩展：

### 进制转换（以八进制为例）
讲者首先解释了从八进制转换到十进制的过程：
- 八进制的**基数**是8，而不是常见的10。
- 将数字 257 八进制转为十进制：
  - \(2 \times 8^2 + 5 \times 8^1 + 7 \times 8^0\)
  - 计算结果：\(2 \times 64 + 5 \times 8 + 7 = 128 + 40 + 7 = 175\)。
  
  这个过程与十进制类似，只是基数从10变成了8，指数计算规则保持不变。通过这一过程，讲者展示了如何通过简单的算术操作在不同进制系统之间进行转换。

### 进制的任意性
讲者指出，不同的进制系统是**任意的**，没有任何进制本质上比其他进制更“正确”或“错误”。进制系统的选择仅影响数字的表示形式，而不改变数字的本质。类似于我们在公制和英制单位之间的转换（例如温度、距离、重量的转换），我们也可以在不同进制之间进行转换。

### 二进制系统
讲者随后介绍了二进制系统：
- 二进制的**基数**是2，只有两个数字：0 和 1。
- 在二进制中，任意数字都可以表示为一组 0 和 1。与十进制不同，二进制只用到了两个符号。

以二进制数 **0110** 为例，将其转换为十进制：
- 这个二进制数表示为：
  - \(0 \times 2^3 + 1 \times 2^2 + 1 \times 2^1 + 0 \times 2^0\)
  - 计算结果：\(0 \times 8 + 1 \times 4 + 1 \times 2 + 0 = 4 + 2 = 6\)。

### 限制位数的二进制表示
讲者进一步讨论了**位数的限制**对于二进制数的影响：
- 例如，一个两位的二进制数只能表示 0 到 3 的值：
  - 00（二进制） = 0（十进制）
  - 01（二进制） = 1（十进制）
  - 10（二进制） = 2（十进制）
  - 11（二进制） = 3（十进制）

与十进制相似，限制位数也会限制可表示的数的范围。如果在十进制中限制为两位数，则只能表示 0 到 99 的数，无法表示 100 及以上的数字。

### 二进制位数的影响
- 二进制中的**位数**决定了可以表示的数的范围。一个 \(n\) 位的二进制数可以表示从 0 到 \(2^n - 1\) 的数字。例如，三位二进制数可以表示的最大数字是 \(2^3 - 1 = 7\)：
  - 000（二进制） = 0（十进制）
  - 001（二进制） = 1（十进制）
  - 010（二进制） = 2（十进制）
  - 011（二进制） = 3（十进制）
  - 100（二进制） = 4（十进制）
  - 101（二进制） = 5（十进制）
  - 110（二进制） = 6（十进制）
  - 111（二进制） = 7（十进制）

### 练习与扩展
讲者鼓励大家练习通过类似的方法，将二进制数转换为十进制数，以加深对这个概念的理解。例如，对于二进制数 **101**，其表示的是：
- \(1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 = 4 + 0 + 1 = 5\)。

### 二进制和计算机
讲者提到，计算机之所以采用二进制系统，是因为其硬件结构更适合处理只有两个状态（0 和 1）的数据。为了更深入地理解计算机如何进行二进制运算，首先需要理解这些数在不同位数下的表示方式。

### 结论
- 不同进制系统是任意选择的，没有任何进制系统在本质上更优。
- 进制的基础是将不同位置上的数字与基数的幂相乘，再将这些值相加来得到最终的数值。
- 计算机使用二进制是因为其硬件结构与处理二进制数据的效率更高。理解进制转换，尤其是二进制的运算，是计算机科学的重要基础。





### 进制转换与表示

1. **八进制到十进制的转换**：
   - 在八进制中，基数为 8，而不是十进制中的 10。
   - 讲者以 **257 八进制**为例，将其转换为十进制：
     \[
     257_8 = 2 \times 8^2 + 5 \times 8^1 + 7 \times 8^0
     \]
     计算步骤：
     \[
     2 \times 64 + 5 \times 8 + 7 \times 1 = 128 + 40 + 7 = 175_{10}
     \]
   - 通过这个例子，讲者强调八进制和十进制之间的转换方式只是基数不同，其他计算规则如指数的处理保持不变。

2. **进制系统的任意性**：
   - 讲者指出，不同进制系统的选择是**任意的**，并没有某个进制比其他进制更“正确”或“错误”。无论是十进制、八进制还是二进制，所有进制都可以表示所有数字，只是**表示方式不同**。
   - 类似于不同社会中使用的计量单位，如公制与英制单位的转换，进制之间的转换也是如此，尽管可能会比较繁琐，但并没有任何本质上的对错之分。

### 二进制与进制对比

3. **二进制的基本特性**：
   - 二进制的基数为 2，只有两个数字：0 和 1。
   - 比较不同进制系统：
     - **十进制**有 10 个数字（0-9）。
     - **八进制**有 8 个数字（0-7）。
     - **二进制**只有 2 个数字（0 和 1）。
   - 以二进制数 **0110** 为例，将其转换为十进制：
     \[
     0110_2 = 0 \times 2^3 + 1 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 = 4 + 2 = 6_{10}
     \]
   - 通过这个例子，讲者展示了二进制到十进制的转换方法，与之前的八进制转换类似，只是基数和对应的幂次不同。

4. **计算机与二进制**：
   - 讲者解释了现代计算机为何采用二进制系统。计算机的硬件结构使得处理只有两种状态（0 和 1）的数据更为简单和高效。
   - 为了进一步理解计算机中的二进制计算，必须首先理解二进制数字的表示方式。

5. **二进制中的位数与范围限制**：
   - 与十进制不同，二进制中必须**指定位数**，因为计算机的内存是有限的，每个二进制数的表示都需要规定长度。
   - **两位的二进制数**能表示的范围为 0 到 3：
     - 00（二进制） = 0（十进制）
     - 01（二进制） = 1（十进制）
     - 10（二进制） = 2（十进制）
     - 11（二进制） = 3（十进制）
   - 类似地，十进制中若限制为两位数，则能表示的范围是 0 到 99。

6. **三位二进制数的表示**：
   - 以三位二进制数为例，其表示范围为 0 到 \(2^3 - 1 = 7\)：
     - 000（二进制）= 0（十进制）
     - 001（二进制）= 1（十进制）
     - 010（二进制）= 2（十进制）
     - 011（二进制）= 3（十进制）
     - 100（二进制）= 4（十进制）
     - 101（二进制）= 5（十进制）
     - 110（二进制）= 6（十进制）
     - 111（二进制）= 7（十进制）
   - 例如，对于二进制数 **101**，其表示的十进制数为：
     \[
     101_2 = 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 = 4 + 0 + 1 = 5_{10}
     \]

### 进制与二进制计算的熟练掌握

7. **熟悉二的幂次**：
   - 讲者指出，作为计算机科学家，必须对**二的幂次**非常熟悉，因为它是二进制计算的基础。常用的二的幂次包括：
     \[
     1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024
     \]
   - 这些幂次不仅在二进制运算中有重要作用，在计算机存储容量（如内存、硬盘）和其他计算机科学的概念中也广泛应用。

### 结论
- 不同的进制系统是任意的选择，数字在不同进制中只是**表示方式**不同，而其本质和计算规则保持一致。
- 理解二进制的基本运算和表示方式是理解计算机运作的基础，因为计算机通过二进制数进行所有的计算与存储操作。



### 二进制与十进制的转换

1. **三位二进制数的计算**：
   讲者使用三位二进制数 **101** 为例，解释如何将二进制数转换为十进制：
   \[
   101_2 = 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 = 4 + 0 + 1 = 5_{10}
   \]
   - **2^2 = 4**，表示第一个位置的 1；
   - **2^1 = 2**，对应的值为 0，所以忽略；
   - **2^0 = 1**，表示最后一个位置的 1。

   通过这种方式可以验证，二进制数 **101** 对应的十进制值是 5。

2. **四位二进制数的范围**：
   - 四位二进制数的最大值是 \(2^4 - 1 = 15\)，最小值是 0。对应的二进制表示从 **0000** 到 **1111**。
   - 以二进制数 **1011** 为例，讲者解释如何将其转换为十进制：
     \[
     1011_2 = 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2^0 = 8 + 0 + 2 + 1 = 11_{10}
     \]
   - 通过类似的步骤，可以将任何四位二进制数转换为对应的十进制值。

### 为什么计算机使用二进制？

3. **二进制的可靠性**：
   讲者接着解释了为什么计算机采用二进制系统，而不是十进制或其他进制。核心原因是二进制在物理实现上更加**可靠**：
   - 计算机中的信息以电子的形式存储，电子信号可能会受到噪声或其他因素的干扰，使得信号不够稳定。如果我们使用十进制系统，则需要区分 10 个不同的电平（如 0 到 9），每个电平的区分会非常精细，容易因为噪声造成错误。
   - 相比之下，二进制只需区分两个状态：0 和 1。即使有一些小的波动，区分这两种状态也相对容易，因此更适合计算机系统。

4. **类比说明**：
   - 讲者用一个比喻来说明这个概念：假设有一个试管，里面可以装水。如果用十进制表示，那么水位可以是从 0 到 9 的任意一个高度。如果水位稍有波动，数字可能会从 7 变成 6 或 8，这样就会导致错误。
   - 但如果只区分水满（1）或空（0），即使有一些波动，也可以很容易地判断状态是 0 还是 1。

### 计算机语言中的二进制表示

5. **二进制数的应用**：
   - 讲者指出，二进制是**现代计算机的语言**，因为它具有高度的可靠性，能有效地存储和处理数据。
   - 在现代计算机中，我们使用 n 位二进制数来表示从 0 到 \(2^n - 1\) 的所有正整数。
   
6. **拓展问题**：
   - 仅仅表示正数还不够，现代计算机还需要处理负数、浮点数、字符串等更多类型的数据。接下来，讲者将讨论如何使用二进制来表示这些数据类型。

### 下一步：负数的表示

7. **如何表示负数**：
   - 由于计算机只能处理 0 和 1，因此无法直接在数字前加负号（不像手写的代数表达式可以直接加上负号）。
   - 下一步将介绍如何通过二进制系统来表示负数，并继续探讨如何表示浮点数和其他复杂的数据类型。

### 总结
- **二进制的优势**在于其在计算机物理层面的可靠性，通过仅处理两个状态（0 和 1），可以有效避免信号干扰带来的错误。
- **二进制与十进制的转换**可以通过逐位计算幂次值并加总来实现。
- 接下来将讨论如何使用二进制系统表示更多的数字类型，如负数和浮点数。





### 负数的二进制表示

1. **引入问题：无负号表示**
   - 在计算机中，无法像在纸上写代数那样直接在数字前加一个负号，因为计算机只能处理 0 和 1 两种状态。
   - 因此，需要通过二进制的**0 和 1**来表示正数和负数，并进行一些额外的编码操作。

2. **简单的符号位表示法**：
   - 一种最直观的方法是使用二进制数的**最高位**（最左边的一位）作为符号位：
     - **0** 表示正数；
     - **1** 表示负数。
   - 例如，对于三位有符号的二进制数：
     - 正数部分（符号位为 0）：\( 000_2, 001_2, 010_2, 011_2 \) 对应 \( 0, 1, 2, 3 \)；
     - 负数部分（符号位为 1）：\( 100_2, 101_2, 110_2, 111_2 \) 对应 \( -0, -1, -2, -3 \)。

3. **符号位表示的局限性**：
   - 符号位方法看似简单易懂，但存在**负零**的问题：\(000_2\) 和 \(100_2\) 分别表示正零和负零，这在数学上并无实际意义。
   - 另外，这种表示方法的计算效率不高，对于计算机来说也较为繁琐。因此，尽管符号位方法在概念上容易理解，实际应用中并不是最佳选择。

### 二进制的补码表示法

4. **引入补码表示法**：
   - 为了解决符号位表示法中的问题，计算机使用了**二进制补码**（Two's Complement）来表示正数和负数。
   - 在补码表示法中，正数的表示与无符号数相同，而负数则通过**翻转**正数的位（取反）并**加 1** 来表示。

5. **补码的计算步骤**：
   - **正数的表示**：
     - 例如，三位二进制数 6 用四位二进制表示为 \( 0110_2 \)：
       \[
       0110_2 = 2^2 + 2^1 = 4 + 2 = 6_{10}
       \]
   - **负数的表示**：
     - 要得到 -6，首先对 6 的二进制数进行**逐位取反**（**补码**）：
       \[
       0110_2 \quad \text{取反} \quad 1001_2
       \]
     - 然后再**加 1**：
       \[
       1001_2 + 1 = 1010_2
       \]
       所以，-6 的补码表示为 \( 1010_2 \)。

6. **为什么补码有效？**
   - **符号位一致性**：补码中的**最高位**（最左边的一位）仍然表示符号位——1 表示负数，0 表示正数。
   - **消除负零**：通过补码表示，负零的问题消失了，因为 \(0000_2\) 表示 0，而没有单独的负零表示。
   - **便于计算**：补码表示的最大优势在于它简化了二进制加减法操作。在补码表示下，计算机可以使用相同的加法电路来处理加法和减法运算，不需要额外的减法逻辑。

7. **补码的计算实例**：
   - 让我们再看一个例子，用三位二进制表示 -3：
     - 正数 3 的二进制表示为 \( 011_2 \)。
     - 对其取反，得到 \(100_2\)。
     - 加 1，得到 \(101_2\)，即 -3 的补码表示为 \(101_2\)。

### 结束语与展望

8. **补码与计算机效率**：
   - 虽然补码表示法对于人类来说不如符号位表示直观，但它在计算机中非常高效，解决了多种符号处理和计算问题。
   - 接下来，讲者会继续讨论如何通过二进制表示**小数**和**负数**，并进一步解释计算机如何对这些表示进行**计算和操作**。





### 二进制补码表示法的进一步解析

1. **正数的补码表示**：
   - 在使用补码表示正数时，最高位（最左位）为 0。例如：
     - 三位的二进制数 \(011\) 对应的十进制是 \(3\)，表示方式为：\(2^1 + 2^0 = 2 + 1 = 3\)。

2. **负数的补码表示**：
   - 要表示负数，通过将正数的二进制位**取反**（翻转每一位）并**加 1** 来实现。例如，如何将三位数的 \(1\) 转换为 \(-1\)：
     1. 取 \(001_2\) 的反码，得到 \(110_2\)。
     2. 对其加 1，得到 \(111_2\)，即为 \(-1\) 的补码表示。
   
3. **补码表示的简便性**：
   - 补码的一个重要特性是使**零的表示唯一**。正如讲者所示，计算 \(000_2\) 的反码 \(111_2\)，加 1 后，产生了一个四位数 \(1000_2\)，其中的溢出位（最高位）被丢弃，最终得到 \(000_2\)，即零。
   - 因此，补码系统中没有“负零”的问题，这比符号位系统要好得多。

### 处理负数的补码运算

4. **具体示例：-2 的补码表示**：
   - **翻转 \(010_2\)**：将二进制数 \(2_2\) 翻转，得到 \(101_2\)。
   - **加 1**：对其加 1，得到 \(110_2\)，即为 \(-2\) 的补码表示。
   
5. **具体示例：-3 的补码表示**：
   - **翻转 \(011_2\)**：将二进制数 \(3_2\) 翻转，得到 \(100_2\)。
   - **加 1**：对其加 1，得到 \(101_2\)，即为 \(-3\) 的补码表示。

6. **补码表示零的结果**：
   - 讲者展示了，当你将 \(000_2\) 翻转为 \(111_2\) 后，加 1 得到 \(1000_2\)，其中溢出的第四位被丢弃，留下 \(000_2\)，表示零。因此，在补码系统中，零始终表示为 \(000_2\)，没有负零的情况。

### 为什么补码对计算机有用？

7. **简化计算**：
   - 虽然对人类而言，补码表示可能稍显复杂，但对于计算机来说，它极大地简化了**加法和减法运算**。使用补码，计算机无需额外的减法运算电路，因为**加法和减法可以使用相同的逻辑处理**。
   
8. **唯一的零表示**：
   - 另一个补码的好处是，它消除了符号位表示法中的“正零”和“负零”的矛盾情况，使零的表示唯一，从而避免了重复。

### 缺失的数：补码范围问题

9. **补码系统中的数值范围**：
   - 在三位二进制补码系统中，可以表示的数值范围为 \(-4\) 到 \(3\)。正数部分包括 \(0, 1, 2, 3\)，负数部分包括 \(-1, -2, -3, -4\)。
   - 由于三位补码数的表示范围是 \(-2^{n-1}\) 到 \(2^{n-1} - 1\)，所以当使用三位二进制补码时，能表示的最大负数是 \(-4\)（即 \(100_2\)），而不是 -8 或其他。

10. **缺失的数解释**：
   - 讲者提到，我们在三位补码系统中可以表示的数为 \(7\) 个，而不是传统的 \(8\) 个，这是因为最高位的一个数（\(100_2\)）被用来表示最小的负数 \(-4\)，因此少了一个正数。
   - **100_2** 对应的补码数值是 \(-4\)，而不是其他更大的正数。

### 小结

- 补码表示法尽管对人类而言较为复杂，但对于计算机来说，它极大地简化了加法、减法等运算，同时也消除了“负零”等问题。
- 在补码系统中，最高位的 1 表示负数，通过补码（翻转位元并加 1）可以轻松表示负数，这使得计算机处理正负数时能够使用相同的电路逻辑，提升了计算效率。







### 二进制补码运算的优势

1. **补码表示法的特殊之处**：
   - 在三位二进制补码系统中，负数的范围是 \(-4\) 到 \(-1\)，而正数的范围是 \(0\) 到 \(3\)。因为补码使用最高位表示符号，负数比正数多一个，导致**负数范围比正数范围大一**。例如，三位二进制补码中的 \(-4\) 用 \(100_2\) 表示，而正数的最大值是 \(3\) 用 \(011_2\) 表示。
   - 当你将 \(100_2\) 视为补码时，它对应 \(-4\) 的值。通过将 \(100_2\) 转换为它的补码，我们得到正数 \(4_2\)，然后通过逻辑推断确认其对应负数为 \(-4\)。

2. **补码系统中的对称性**：
   - 在无符号二进制数中，三位二进制数的范围是 \(0\) 到 \(7\)，而在三位补码数中，范围是 \(-4\) 到 \(3\)。这表现出一种**非对称性**，即负数的范围比正数多一个。这种非对称性是由于只有一个 0（没有负零）的结果。

3. **补码的真正优势**：
   - 虽然对人类来说，补码表示负数时看起来更复杂，因为我们需要进行位的翻转和加 1 操作，才能获得负数的表示，但补码的优势在于**简化了计算机中的算术运算**。这主要体现在加减法操作中，补码能够统一处理正数和负数的运算。

### 补码运算实例

4. **加法运算实例：2 + 2**：
   - 让我们首先进行一个无符号的二进制加法运算。将两个二进制数 \(0010_2\) 和 \(0010_2\) 相加：
     \[
     0010_2 + 0010_2 = 0100_2
     \]
     结果为 \(0100_2\)，即 4。这与十进制的加法一致，二进制的加法操作类似于十进制加法，只是进位规则不同。

5. **旧式符号位表示法的加法问题：2 + (-2)**：
   - 使用旧的符号位表示法，我们可以通过简单地改变符号位来表示负数。比如，\(0010_2\) 是正数 2，而 \(1010_2\) 是负数 -2。
   - 如果尝试将二者相加：
     \[
     0010_2 + 1010_2 = 1100_2
     \]
     结果为 \(1100_2\)，但这个结果并不代表零，这是因为符号位和数值位混在一起，导致加法操作无效。

6. **补码系统下的加法：2 + (-2)**：
   - 在补码系统中，加法运算非常自然且有效。我们首先计算 \(-2\) 的补码：
     - \(2_2\) 的二进制表示为 \(0010_2\)。
     - 取反 \(1101_2\)，加 1 得到 \(-2\) 的补码表示 \(1110_2\)。
   - 现在我们将 \(2_2\) 和 \(-2_2\) 相加：
     \[
     0010_2 + 1110_2 = 0000_2
     \]
     结果为 \(0000_2\)，即 0。这是期望的结果。

7. **溢出问题**：
   - 计算 \(1+1=2\) 时，在二进制中，2 表示为 \(10_2\)，因此会发生**进位**。例如，在进行补码运算时，如果最终得到的结果超过了系统的最大表示位数，会产生溢出位，但这个溢出位会被忽略。
   - 例如，在三位补码系统中，计算 \(2 + (-2)\) 时，最高位的进位将被丢弃，产生正确的结果 0。

### 总结

- **补码的设计**虽然对人类来说不如简单的符号位直观，但它极大地简化了计算机的加法和减法运算，避免了符号位与数值位的冲突。
- 补码的关键优势在于它能让正负数的运算使用相同的二进制电路逻辑，提升了计算效率。
- 补码表示还确保了**唯一的零**，并且能够处理溢出位，从而避免出现错误的计算结果。





### 二进制补码运算详解与计算实例

1. **补码中的加法运算**：
   - 补码系统中的加法运算相当简单，甚至能够自动处理负数的运算。举个例子：
     - 我们有两个二进制数，一个是 2 (\(0010_2\))，另一个是 -2 (\(1110_2\))。将它们相加：
       \[
       0010_2 + 1110_2 = 0000_2
       \]
       结果为 \(0000_2\)，即 0。这是理想的结果，因为 2 + (-2) 应该等于 0。尽管我们遇到了溢出位（第五位的进位），但这个进位被忽略，因此结果是正确的。

2. **溢出位处理**：
   - 在补码运算中，如果结果的进位超出了规定的位数（例如四位数的第五位），则称为**溢出**。这些多余的位会被丢弃，不影响计算结果。补码系统中，溢出位的处理是非常自然的，不需要特别关心溢出位。

3. **加法的第二个示例：3 + (-3)**：
   - 假设我们在四位补码系统中有 \(0011_2\) 表示 3。为了表示 -3，我们先将 3 的位翻转（取反）并加 1：
     \[
     0011_2 \text{取反为} 1100_2 + 1 = 1101_2
     \]
     - \(1101_2\) 表示 -3。
   - 将 3 和 -3 相加：
     \[
     0011_2 + 1101_2 = 0000_2
     \]
     结果再次是 0，验证了补码系统的有效性。

4. **为什么补码对计算机有用？**：
   - 补码表示法使得二进制的**加减法**变得非常简便。正如我们所见，计算机只需执行普通的二进制加法，补码可以处理正数与负数的加法，而不需要额外的减法电路。
   - 虽然补码对人类来说稍微难以直观理解，但对于计算机硬件而言，它极大地简化了硬件设计，使加法和减法可以通过相同的电路实现。

### 如何处理不同表示法下的二进制数

5. **区分无符号数与补码数**：
   - 当我们看到一个二进制数时，必须明确它的表示法。比如，四位的二进制数 \(0111_2\)：
     - 如果它是**无符号数**，则表示十进制的 7。
     - 如果它是**四位补码数**，仍然表示 7。
   - 但对于 \(1011_2\)，情况就不同了：
     - 如果它是无符号数，则表示 11；
     - 如果它是补码数，则表示 -5。

6. **补码数的还原**：
   - 当最高位为 1 时，我们知道这是一个负数，因此需要通过**还原补码**来获得其对应的十进制负数。还原的过程包括：
     1. **减去 1**：从补码数中减去 1。
     2. **取反**：将每一位翻转。
   - 例如，\(1011_2\) 是四位补码数：
     - 首先减去 1 得到 \(1010_2\)；
     - 然后取反，得到 \(0101_2\)，即 5。因此，\(1011_2\) 对应的十进制值是 -5。

7. **练习示例**：
   - 例如，给定一个四位补码数 \(1100_2\)，将其转换为十进制：
     1. **识别符号位**：最高位为 1，表示负数。
     2. **还原补码**：
        - 首先减去 1，得到 \(1011_2\)；
        - 然后取反，得到 \(0100_2\)，即 4。因此，\(1100_2\) 对应的十进制值是 -4。

### 总结

- **补码的主要优点**在于它使得加法和减法可以使用同一套电路进行计算，这对于计算机硬件设计非常有利。
- **溢出处理**是二进制补码系统的天然优势，多余的进位（溢出位）可以被自动丢弃，不会影响计算结果。
- 对于不同的二进制数表示，我们必须明确其使用的是**无符号数**还是**补码数**，并根据相应的规则进行转换。





### 二进制补码运算与小数表示

1. **二进制补码表示的运算复习**：
   - **负数的二进制补码运算**：在补码表示中，我们通过取反并加 1 来得到负数的二进制表示。以 -5 为例：
     - 首先，将 \(5\) 的二进制表示 \(0101_2\) 取反，得到 \(1010_2\)。
     - 然后加 1，得到 \(1011_2\)，这是 -5 的补码表示。
   - 我们还可以通过相反的操作，即减 1 后取反，来从补码中还原出正数。对于 \(1011_2\)，减去 1 得到 \(1010_2\)，取反得到 \(0101_2\)，即十进制的 5。

2. **总结补码运算的优点**：
   - 补码表示法使得计算机能够在硬件层面通过简单的二进制加法处理正数和负数的运算，这简化了电路设计。
   - **统一的零**：在补码系统中，零只有一种表示方式，避免了正零和负零的问题。
   - **溢出处理**：在加法或减法运算中，多余的进位（溢出位）会被自动丢弃，保证结果正确。

3. **小数在二进制中的表示**：
   - 讲者提到，**小数**在二进制中使用类似于科学计数法的表示形式，称为**浮点数**表示。浮点数的表示由以下几个部分组成：
     - **尾数**（mantissa）：表示数值部分，通常是一个带符号的整数。
     - **指数**（exponent）：表示浮点数的倍数或缩放因子，也带符号。
     - **基数**（base）：通常是 2 或 10，表示数的进制。
   - 例如，十进制中的 0.1 可以表示为：
     \[
     1 \times 10^{-1}
     \]
     - 尾数为 1，指数为 -1，基数为 10。在二进制中，类似的表示法被用来处理小数。

4. **为什么浮点数有效？**：
   - 浮点数的表示非常适合处理小数和非常大的或非常小的数。因为尾数和指数都是整数，而计算机已经能够高效处理带符号的整数，浮点数的计算可以通过现有的整数运算单元完成。
   - 浮点数使得在二进制中表示小数变得可能，尤其是在科学计算、金融计算等需要处理大量小数运算的场景中。

### 逻辑运算与布尔代数

5. **布尔代数的介绍**：
   - 计算机不仅处理数字，还处理**逻辑值**（True 和 False）。在二进制系统中，True 用 1 表示，False 用 0 表示。
   - 三种基本的**布尔运算**包括：
     - **与（AND）**：两个条件都为 True 时，结果为 True。
     - **或（OR）**：任一条件为 True 时，结果为 True。
     - **非（NOT）**：对条件取反，True 变 False，False 变 True。

6. **布尔运算的真值表**：
   - **与运算**：只有当两个输入都为 1 时，结果为 1；否则为 0。
   - **或运算**：当任一输入为 1 时，结果为 1；如果两个输入都为 0，结果为 0。
   - **非运算**：将输入的值翻转，0 变 1，1 变 0。

### 计算机中的布尔逻辑

7. **布尔逻辑在计算机中的作用**：
   - 计算机使用布尔逻辑来进行决策和控制流。例如，程序中的条件判断语句（如 `if` 语句）依赖于布尔逻辑来确定接下来要执行的代码。
   - 逻辑门（如 AND、OR、NOT 门）是计算机硬件中基本的电路单元，通过组合这些门可以实现复杂的逻辑和运算。

8. **布尔运算与二进制的结合**：
   - 通过将布尔逻辑与二进制数字相结合，计算机可以进行复杂的算术运算、逻辑判断和数据操作。这些运算是所有现代计算机处理数据的基础。

### 小结与下一步

- 我们已经讨论了如何在二进制中表示**正数、负数和小数**，以及如何使用补码进行负数运算。接下来，讲者将深入探讨如何使用这些表示法来进行**实际的计算**，例如加法、减法、乘法、除法等。
- 还将介绍如何利用**布尔代数**来构建现代计算机的基础逻辑，并展示计算机如何执行复杂的运算。







### 布尔逻辑与计算机构建基础

1. **布尔运算基础**：
   - **逻辑与（AND）**：当两个输入值都为 True 时，结果为 True；其他情况下，结果为 False。
     - 真值表：
       \[
       \begin{array}{c|c|c}
       A & B & A \land B \\
       \hline
       0 & 0 & 0 \\
       0 & 1 & 0 \\
       1 & 0 & 0 \\
       1 & 1 & 1 \\
       \end{array}
       \]
     - 例如，当 \(A = 1\) 且 \(B = 1\) 时，逻辑与结果为 \(1\)。

   - **逻辑或（OR）**：只要有一个输入为 True，结果为 True；如果两个输入都为 False，结果为 False。
     - 真值表：
       \[
       \begin{array}{c|c|c}
       A & B & A \lor B \\
       \hline
       0 & 0 & 0 \\
       0 & 1 & 1 \\
       1 & 0 & 1 \\
       1 & 1 & 1 \\
       \end{array}
       \]

   - **逻辑非（NOT）**：只有一个输入，结果是输入的相反值。
     - 真值表：
       \[
       \begin{array}{c|c}
       A & \neg A \\
       \hline
       0 & 1 \\
       1 & 0 \\
       \end{array}
       \]

2. **计算机中的布尔运算**：
   - 布尔运算是一种简单的计算形式，输入是布尔变量（True/False 或 0/1），输出也是布尔变量。这些运算构成了计算机处理逻辑判断的基础。
   - 逻辑与、或、非可以组合形成复杂的逻辑电路，并且是构建现代计算机的**核心元素**。

3. **逻辑门**：
   - 布尔运算的物理实现通过**逻辑门**来完成。每个逻辑门都有特定的符号和功能：
     - **与门（AND Gate）**：表示逻辑与操作，符号为一个带有“·”的 D 形图。
     - **或门（OR Gate）**：表示逻辑或操作，符号为一个带有“+”的弯曲 D 形图。
     - **非门（NOT Gate）**：表示逻辑非操作，符号为一个带小圆点的三角形。

4. **逻辑门的工作原理**：
   - 与门、或门和非门各自执行与、或、非运算，输入是 0 或 1（False 或 True），输出也是 0 或 1。
   - 这些逻辑门是现代计算机的基础组件，通过组合它们可以构建复杂的计算系统。

### 构建现代计算机的基础

5. **从逻辑门到计算机**：
   - 通过组合与、或、非门，可以实现所有的布尔运算，并且能够构建更复杂的逻辑电路，例如**加法器**、**乘法器**等，这些电路可以执行基本的算术运算。
   - 例如，**全加器电路**（Full Adder）可以使用逻辑门来实现二进制数的加法，它是计算机进行算术运算的基础之一。

6. **为什么只需要这三种操作？**：
   - 虽然逻辑与、或、非运算看起来非常简单，但它们已经足够强大，能够表达所有的布尔逻辑。
   - 通过组合这些基本操作，可以实现任意复杂的运算，构建完整的计算系统。
   - **冯·诺依曼架构**的计算机正是基于这些逻辑运算来实现计算的。

### 物理实现：从逻辑门到晶体管

7. **逻辑门的物理实现**：
   - 逻辑门的底层实现通常通过**晶体管**完成。晶体管可以用来构建与、或、非门，从而实现逻辑运算。
   - 晶体管通过控制电流的通过与否来模拟 0 和 1 的状态。例如，两个晶体管可以串联组成与门，只有当两个晶体管都导通时，电流才能通过，表示结果为 1。

8. **计算机的核心逻辑**：
   - 通过数十亿个晶体管的组合，现代计算机能够执行非常复杂的计算。虽然底层运算依赖于简单的逻辑与、或、非，但这些运算的组合能够实现所有的计算任务。

### 小结与展望

- **逻辑与、或、非**运算是现代计算机计算的基石。通过组合这些简单的逻辑操作，计算机可以执行复杂的计算任务。
- 接下来，我们将探讨如何使用逻辑门实现更复杂的计算电路，如加法器、乘法器等，并深入了解计算机如何从这些基础组件构建出功能强大的处理器。







### 使用晶体管构建逻辑门

1. **晶体管的基本概念**：
   - 晶体管是现代计算机的基础，用于控制电流的通过与否，模拟二进制状态：**0** 表示无电流（开关断开），**1** 表示有电流（开关闭合）。
   - 我们可以使用晶体管构建**逻辑门**，这些逻辑门执行布尔运算，如与（AND）、或（OR）、非（NOT）。

2. **构建 AND 门**：
   - **逻辑与（AND）**运算：只有当两个输入都为 1 时，输出才为 1，否则输出为 0。
   - 通过将两个晶体管**串联**（即将一个晶体管的输出连接到下一个晶体管的输入），可以实现 AND 门：
     - 当两个输入 \(A\) 和 \(B\) 都为 1 时，电流能够从顶部流到底部，输出为 1。
     - 如果任一晶体管处于关闭状态（输入为 0），电流被阻断，输出为 0。
   - 这构成了 AND 门的布尔运算：
     \[
     \begin{array}{c|c|c}
     A & B & A \land B \\
     \hline
     0 & 0 & 0 \\
     0 & 1 & 0 \\
     1 & 0 & 0 \\
     1 & 1 & 1 \\
     \end{array}
     \]
   - 串联结构表示只有在两个输入都为 1 时电流才能通过。

3. **构建 OR 门**：
   - **逻辑或（OR）**运算：只要有一个输入为 1，输出就为 1。
   - OR 门的晶体管配置为**并联**，而不是串联：
     - 并联意味着只要任一晶体管允许电流通过（输入为 1），输出就为 1。
     - 当两个输入都为 0 时，电流无法通过，输出为 0。
   - OR 门的布尔运算如下：
     \[
     \begin{array}{c|c|c}
     A & B & A \lor B \\
     \hline
     0 & 0 & 0 \\
     0 & 1 & 1 \\
     1 & 0 & 1 \\
     1 & 1 & 1 \\
     \end{array}
     \]
   - 并联结构确保只要有一个输入为 1，电流就能通过并输出 1。

4. **构建 NOT 门**：
   - **逻辑非（NOT）**运算：将输入的布尔值取反，即输入为 0 时输出为 1，输入为 1 时输出为 0。
   - NOT 门的设计仅需要一个晶体管：
     - 当输入为 0 时，晶体管关闭，电流通过并输出 1。
     - 当输入为 1 时，晶体管打开，电流被阻断，输出 0。
   - NOT 门的布尔运算为：
     \[
     \begin{array}{c|c}
     A & \neg A \\
     \hline
     0 & 1 \\
     1 & 0 \\
     \end{array}
     \]

### 逻辑门的组合与计算

5. **逻辑门的组合**：
   - 通过将 AND、OR、NOT 门组合，可以构建更复杂的逻辑电路。这些电路能够实现诸如加法、乘法等更复杂的运算。
   - 例如，两个 AND 门和一个 OR 门的组合可以构建一个**半加器**（用于二进制加法）。

6. **构建复杂计算**：
   - 通过组合这些基本的逻辑门，计算机能够执行二进制运算、比较操作和条件判断等。
   - **计算的核心**在于通过晶体管构建的逻辑门能够处理任意的布尔运算，进而实现二进制数的加法、减法、乘法和除法。

### 小结

- **AND、OR、NOT** 门是计算机进行逻辑运算的基础，晶体管通过串联或并联的方式实现这些逻辑门。
- 通过组合这些逻辑门，可以构建复杂的逻辑电路和计算单元，最终构建出功能强大的现代计算机。





### 构建 OR 门和 NOT 门

1. **构建 OR 门**：
   - **逻辑或（OR）**运算要求只要有一个输入为 1，输出就为 1。要实现 OR 门的逻辑，我们将两个晶体管**并联**：
     - 当两个晶体管并联时，只要任意一个晶体管允许电流通过（即输入为 1），电流就能从电源流向输出，产生输出 1。
     - 如果两个输入都为 0，晶体管都关闭，电流无法通过，输出为 0。
   - 这就是 OR 门的基本原理。并联晶体管的特性确保了只要有一个输入为 1，输出就为 1，符合 OR 运算的真值表：
     \[
     \begin{array}{c|c|c}
     A & B & A \lor B \\
     \hline
     0 & 0 & 0 \\
     0 & 1 & 1 \\
     1 & 0 & 1 \\
     1 & 1 & 1 \\
     \end{array}
     \]
   - 通过这种并联配置，当任一晶体管允许电流通过时，电流可以流向输出端，最终结果符合 OR 运算的逻辑。

2. **构建 NOT 门**：
   - **逻辑非（NOT）**运算只有一个输入，输出是输入的反转，即输入为 0，输出为 1；输入为 1，输出为 0。
   - NOT 门的设计相对简单，只需要一个晶体管和一个电阻：
     - 当输入为 0 时，晶体管关闭，电流通过电阻流向输出，结果为 1。
     - 当输入为 1 时，晶体管打开，电流不再经过电阻，直接通过晶体管流走，输出为 0。
   - NOT 门的真值表如下：
     \[
     \begin{array}{c|c}
     A & \neg A \\
     \hline
     0 & 1 \\
     1 & 0 \\
     \end{array}
     \]

### 晶体管与现代计算机的关系

3. **晶体管的规模化与计算能力**：
   - 晶体管是现代计算机中最小的计算单元，通过控制电流的流动，实现二进制的逻辑操作。
   - 随着技术进步，晶体管的尺寸越来越小。现代计算机能在一个微小的芯片中集成数十亿个晶体管，从而实现巨大的计算能力。
   - 晶体管的微缩和高密度排列使得我们能在像手机这样的设备中进行复杂的计算任务。

4. **从逻辑门到计算**：
   - 我们已经通过晶体管构建了 AND、OR、NOT 门。虽然这些逻辑操作看似简单，但通过组合这些逻辑门，可以执行更复杂的计算，例如二进制加法、乘法等。
   - **逻辑电路的组合**：通过将多个逻辑门组合，可以构建出例如加法器（用于二进制加法）等复杂电路。计算机的所有复杂运算都源自这些基本逻辑门的组合。

5. **逻辑门的扩展与计算**：
   - 使用逻辑门可以实现复杂的布尔代数表达式，并且通过组合这些基本的布尔运算，我们可以执行诸如加法、减法、乘法等计算操作。
   - 例如，通过组合 AND、OR 和 NOT 门，可以构建出一个**全加器**（Full Adder），用于二进制数的加法。通过进一步扩展，这些逻辑电路可以形成现代计算机的算术逻辑单元（ALU）。

### 小结与展望

- 我们已经使用晶体管构建了 AND、OR 和 NOT 门，这些逻辑门是计算机逻辑运算的基础。通过组合这些逻辑门，可以实现更复杂的逻辑电路，从而构建现代计算机的核心运算部件。
- 接下来，将展示如何通过这些逻辑门来实现实际的计算任务，例如加法、乘法，以及计算机是如何通过这些基本逻辑来执行复杂的计算任务。





