---
layout: page
title: L09 Tree Recursion
permalink: /L09
description: "Lecture 9. Tree Recursion"
nav_order: 9




---

# Lecture 9. Tree Recursion

### 公告

**期中考试成绩已发布**，如果对评分有异议，可以通过 GradeScope 提交**重新评分申请**，截止日期为**周一**。可以在 Piazza 上提问，但如果要正式修改成绩，必须通过 GradeScope 提交申请。整体来看，大家在这次具有挑战性的期中考试中表现得非常出色，我为大家的进步感到高兴。

即使有些同学没有解决所有问题，这也是正常的。关键是学习，如果还有一些内容尚未掌握，不用担心，在**期中考试二**和**期末考试**中仍有大量机会来提升。继续努力，专注于尚未完全理解的部分，坚持下去。

我们还监测了考试中的各种**合作行为**，结果显示作弊行为的发生率非常低。大多数同学都按规定独立完成了考试，这很重要，因为课程是**不曲线评分**的，因此他人的分数对你没有影响。专注于自己的进步才是关键。

如果你在 Google Drive 上存有考试视频，请保留这些视频到**周一**，以便我们完成检查。

**Homework 2** 将在今天发布，截止日期为**下周四**。本周没有考试准备环节，取而代之的是**明天下午2:10**的**问答环节**，不会录制，如果有问题可以来参加。

此外，还有一个**完全可选的 Hog 策略比赛**。提交表单已经发布，现在没有时间限制，只要策略在比赛结束前提交即可。你可以提前提交，查看自己在排行榜上的位置。目前，"Blockchain" 策略击败了所有对手，位列第一。

### 递归的回顾与新内容

今天的课程内容与以往不同，**教授 Fried** 录制了一些视频，回顾了上节课的内容。他的讲解方式有些不同，这很有帮助，能让你从多角度复习**递归**的基础。

接下来的课程将是**新内容**，这些内容非常重要，通常需要**实践**才能完全掌握。因此，下周我们会有实验和作业，帮助你巩固这些概念。

### Python 核心内容的总结

到目前为止，我们已经覆盖了成为**Python 程序员**所需的核心计算概念，包括：
- **函数**
- **变量**
- **循环结构**（`while` 和 `for`）
- **条件语句**（`if`、`elif` 和 `else`）

尽管还有很多数据结构和算法需要学习，但这些构成了你编写通用 Python 程序的基础。接下来的课程将进入更复杂的主题，比如**面向对象编程**。

### 递归的美

递归是一种非常**优美**的计算结构，它与之前所学的内容（例如循环和条件判断）不同。递归允许我们通过**自我调用**的方式解决问题，改变了我们对计算过程的思考方式。在接下来的内容中，我们将深入探讨递归的使用和其背后的思想。





### 递归的美与阶乘的迭代实现

在介绍递归之前，先讨论一下**阶乘（Factorial）**运算的定义以及如何用迭代实现它。

#### 阶乘的数学定义
阶乘的符号是**感叹号（!）**，定义如下：
- 对于非负整数 `n`，`n!` 表示从 `n` 到 1 的所有正整数的乘积。
- **特殊情况**：`0! = 1`。

#### 迭代实现阶乘

在写递归版本之前，我们可以用迭代的方法来实现阶乘。通过 `while` 循环逐步计算从 1 到 `n` 的乘积。以下是迭代的 Python 实现：

##### 迭代版阶乘代码：

```python
def factorial(n):
    fact = 1  # 初始化结果
    i = 1     # 计数器，从 1 开始
    while i <= n:
        fact *= i  # 计算累积乘积
        i += 1     # 计数器递增
    return fact  # 返回最终结果
```

**解释：**
- `fact`：用于存储当前的乘积结果，初始值为 `1`。
- `i`：计数器，初始值为 `1`，每次循环递增。
- 在每次循环中，`fact` 被更新为 `fact * i`，计算从 1 到 `n` 的乘积。

##### 特殊情况处理：`n = 0`
在上面的实现中，虽然没有特别处理 `n = 0` 的情况，但代码可以正确处理这一情况。当 `n = 0` 时，循环条件 `i <= 0` 为假，因此直接返回 `fact = 1`。这与 `0! = 1` 的定义一致。

### 递归与迭代的对比

迭代方案通过显式地维护一个变量 `fact` 来计算阶乘。接下来，我们将讨论如何使用递归实现相同的功能，并解释为什么递归在某些情况下是一种更优雅的解决方案。

#### 递归的引入

**递归** 是一种计算思想，它通过**函数调用自身**来解决问题。递归的美在于其解决问题的方式与迭代不同，通常更加简洁、直观。

在递归的实现中，阶乘的定义可以直接映射到函数的结构：
1. 基准情况：`0! = 1`
2. 递归情况：`n! = n * (n-1)!`

##### 递归版阶乘代码：

```python
def factorial(n):
    if n == 0:
        return 1  # 基准情况：0! = 1
    else:
        return n * factorial(n - 1)  # 递归调用
```

**解释：**
- 当 `n = 0` 时，直接返回 `1`。
- 对于其他正整数 `n`，通过递归调用 `factorial(n-1)` 来计算 `n-1` 的阶乘，然后乘以 `n`。

#### 递归与迭代的比较

1. **简洁性**：递归的实现通常比迭代更简洁，逻辑上更接近数学定义。在递归的版本中，代码直接反映了阶乘的数学定义。
2. **状态维护**：迭代通过变量显式地维护当前状态，而递归则通过**函数调用栈**隐式地维护状态。每次递归调用都创建一个新的栈帧，用于存储当前函数的参数和局部变量。
3. **效率**：虽然递归代码更简洁，但每次递归调用会消耗额外的栈空间。如果 `n` 很大，递归可能导致**栈溢出**。迭代版本通常在效率上表现更好。

#### 递归的美

递归不仅仅是一种编程技巧，它改变了我们对计算过程的思考方式。通过将复杂问题分解为更简单的子问题，递归提供了一种优雅的、自然的解决问题的方式。这也是为什么在计算机科学和编程中，递归被广泛应用于诸如**数据结构**（如树、图）和**算法**（如排序、分治算法）中。

接下来的课程将深入讨论递归的应用以及如何在更复杂的问题中使用递归来简化问题的求解过程。





### 阶乘与递归的定义

在前面，我们使用了**迭代**的方法来计算阶乘。接下来，我们将讨论如何通过**递归**实现相同的功能，并且解释为什么递归虽然看似“自我引用”，但它实际上是有效且逻辑严谨的。

#### 阶乘的递归定义

递归是一种通过**自我调用**来解决问题的计算方法。递归定义通常有两个部分：
1. **基准情况**：最简单的情况，它不需要进一步的递归调用。例如，`0! = 1`。
2. **递归情况**：通过对较小问题的递归调用来解决当前问题。例如，`n! = n * (n-1)!`。

##### 阶乘递归实现的代码

```python
def factorial(n):
    if n == 0:
        return 1  # 基准情况：0! = 1
    else:
        return n * factorial(n - 1)  # 递归调用：n! = n * (n-1)!
```

#### 递归的解释

让我们逐步解释为什么递归定义有效，并且与迭代等效。假设我们想计算 `5!`，递归过程如下：

1. **`factorial(5)`**：这一步计算 `5 * factorial(4)`，但 `factorial(4)` 还未计算出结果，因此继续递归。
2. **`factorial(4)`**：计算 `4 * factorial(3)`，继续递归。
3. **`factorial(3)`**：计算 `3 * factorial(2)`。
4. **`factorial(2)`**：计算 `2 * factorial(1)`。
5. **`factorial(1)`**：计算 `1 * factorial(0)`。
6. **`factorial(0)`**：基准情况返回 `1`。

然后，递归开始“回溯”，将计算结果逐级返回：
- `factorial(1) = 1 * 1 = 1`
- `factorial(2) = 2 * 1 = 2`
- `factorial(3) = 3 * 2 = 6`
- `factorial(4) = 4 * 6 = 24`
- `factorial(5) = 5 * 24 = 120`

最终，`factorial(5)` 返回 `120`。

#### 递归与迭代的比较

- **递归简洁性**：递归直接反映了阶乘的数学定义，代码简洁、清晰。相较于迭代，递归更易于理解其本质。
- **状态管理**：递归通过调用栈隐式管理状态，每一次递归调用都会将当前的状态（即 `n` 的值）存储在栈帧中。而迭代通过显式的变量更新来管理状态。
- **效率与空间开销**：递归虽然在概念上简洁，但它会占用更多的栈空间，尤其当 `n` 较大时，递归深度过大可能导致栈溢出。因此，迭代在处理大规模问题时往往更高效。

### 递归定义的有效性

递归定义并不是“自我循环”或“无解的”。递归的关键在于，每一次递归调用都会将问题规模缩小，直到遇到基准情况为止。例如，在计算 `n!` 时，我们通过每次递减 `n`，最终递减到 `0`，这时递归停止并返回已知结果。

通过这种方式，递归逐步“解开”问题，最终返回正确结果。递归的强大之处在于它能够通过分解问题，简洁地解决复杂的计算问题。

#### 总结

递归提供了一种优雅的方式来解决问题。通过递归，我们可以将复杂问题逐步分解，直到遇到基准情况。递归的核心是它允许我们用简单的方式定义和求解看似复杂的问题，如阶乘。这种方式不仅在计算上有效，而且在概念上更接近问题的数学定义。



### 阶乘的递归定义与实现

当我们通过递归的方式定义阶乘时，我们实际上是在定义一个**自我调用的函数**。递归的本质是将一个复杂的问题分解为一个**较小的问题**，直到到达一个**基准情况**。在阶乘的例子中，基准情况是 `0! = 1`，其余情况是通过递归调用自身来完成的。

#### 递归的阶乘定义
1. **基准情况**：`0! = 1`
2. **递归情况**：`n! = n * (n-1)!`

通过递归的定义，每次函数调用时，问题的规模缩小一步，直到遇到基准情况为止。

### 递归实现的代码

```python
def factorial(n):
    if n == 0:
        return 1  # 基准情况：0! = 1
    else:
        return n * factorial(n - 1)  # 递归调用：n! = n * (n-1)!
```

#### 递归过程的解析

当我们调用 `factorial(3)` 时，递归的过程如下：

1. **`factorial(3)`**：返回 `3 * factorial(2)`。此时，`factorial(2)` 还未计算出结果，因此继续递归。
2. **`factorial(2)`**：返回 `2 * factorial(1)`。
3. **`factorial(1)`**：返回 `1 * factorial(0)`。
4. **`factorial(0)`**：基准情况，返回 `1`。

然后递归开始回溯，逐级返回计算结果：
- `factorial(1)` 返回 `1 * 1 = 1`
- `factorial(2)` 返回 `2 * 1 = 2`
- `factorial(3)` 返回 `3 * 2 = 6`

最终，`factorial(3)` 返回 `6`。

#### 递归的计算机制

递归的核心在于：
1. **问题的逐步简化**：每次递归调用时，问题的规模都会减小（如 `n-1`）。
2. **基准情况终止递归**：当遇到基准情况（如 `n=0`）时，递归停止，开始回溯。
3. **结果的累积**：递归的每一层都依赖前一层的结果，逐步构建出最终的结果。例如，在计算 `3!` 时，我们首先计算 `2!`，然后乘以 3。

### 递归与栈的关系

每次递归调用都会将当前的计算状态**压入栈**，等待后续的结果。一旦基准情况触发，栈开始**回溯**，并逐步计算出最终结果。

例如，在计算 `factorial(3)` 时，栈中的计算顺序如下：
- `factorial(3)` 等待 `factorial(2)` 的结果。
- `factorial(2)` 等待 `factorial(1)` 的结果。
- `factorial(1)` 等待 `factorial(0)` 的结果。

当 `factorial(0)` 返回 `1` 后，栈开始回溯，逐步完成计算：
- `factorial(1)` 返回 `1 * 1 = 1`
- `factorial(2)` 返回 `2 * 1 = 2`
- `factorial(3)` 返回 `3 * 2 = 6`

### 递归的特性

1. **递归的简洁性**：递归的代码结构往往更加简洁，特别是在问题本身具有递归结构时（如阶乘、斐波那契数列等）。
2. **递归的效率问题**：递归虽然简洁，但每次递归调用都会占用额外的栈空间，递归深度过大会导致**栈溢出**。对于深度较大的问题，迭代可能是更高效的选择。
3. **递归与迭代的比较**：迭代通过显式的循环和状态更新来处理问题，而递归通过函数调用隐式地管理状态。递归更符合人类思维的自然方式，但需要注意栈空间的开销。

### 总结

递归通过自我调用将复杂问题逐步简化，最终通过基准情况停止递归并回溯结果。在阶乘的例子中，递归简洁地表达了阶乘的数学定义，并且有效地计算出结果。通过理解递归的工作机制，我们可以将递归应用于各种具有递归性质的问题中。





### 递归过程的进一步解析

当我们通过递归实现阶乘或其他函数时，整个计算过程是通过**逐步构建表达式**，并最终通过基准情况停止递归并开始回溯。让我们通过 `factorial(3)` 的例子进一步说明这个过程。

#### 阶乘的递归调用流程

1. **`factorial(3)`**：首先调用自身递归，并返回 `3 * factorial(2)`。但因为 `factorial(2)` 还未计算完成，递归继续。
2. **`factorial(2)`**：返回 `2 * factorial(1)`，再进入下一层递归。
3. **`factorial(1)`**：返回 `1 * factorial(0)`，继续递归调用。
4. **`factorial(0)`**：基准情况触发，返回 `1`。此时递归停止，我们开始回溯并计算结果。

#### 回溯与计算

递归的回溯过程从基准情况开始：

- **`factorial(1)`**：当 `factorial(0)` 返回 `1` 后，计算 `1 * 1 = 1`，并将结果返回给 `factorial(2)`。
- **`factorial(2)`**：使用 `factorial(1)` 的结果，计算 `2 * 1 = 2`，再将结果返回给 `factorial(3)`。
- **`factorial(3)`**：使用 `factorial(2)` 的结果，计算 `3 * 2 = 6`，最后返回 `6` 作为最终结果。

通过这种方式，我们通过递归构建了一个逐步的表达式，最终通过回溯得到了结果。

### 递归返回与表达式的构建

递归的核心在于通过每次调用构建一个表达式，而这个表达式在回溯时逐步完成。例如，在 `factorial(3)` 的计算中，每次调用都构建了一部分表达式：
- `factorial(3)` 构建 `3 * (factorial(2))`
- `factorial(2)` 构建 `2 * (factorial(1))`
- `factorial(1)` 构建 `1 * (factorial(0))`
- 基准情况 `factorial(0)` 返回 `1`，从这里开始所有计算回溯，最终得出结果。

这种递归的表达式构建方式与常规的循环方式不同。在递归中，没有显式的状态更新或变量赋值，而是通过函数调用和返回值的逐步构建来完成计算。这就是递归的独特之处。

### 递归调用中的记忆与返回

递归中的每个函数调用都会保留之前的计算上下文，直到基准情况返回结果后才开始进行计算。正如我们在 `factorial(3)` 中所看到的：
- `factorial(3)` 保持对 `3 * factorial(2)` 的记忆。
- `factorial(2)` 保持对 `2 * factorial(1)` 的记忆。
- 直到 `factorial(0)` 返回 `1`，我们才开始逐步计算并返回结果。

这种**递归堆栈**的机制使得每一层递归能够在正确的上下文中进行计算。

### 递归中的函数调用顺序与等待

递归的关键在于**函数调用的顺序**和**等待返回值**。在一个递归函数中，每次递归调用都必须等待下一个递归调用完成并返回结果，才能继续进行计算。因此，递归的计算过程是一个**逐层深入，层层回溯**的过程。

例如，在 `factorial(3)` 的调用中：
- `factorial(3)` 调用了 `factorial(2)`，并等待其返回。
- `factorial(2)` 又调用了 `factorial(1)`，继续等待。
- 直到 `factorial(0)` 返回 `1` 后，递归才开始逐步回溯并完成所有计算。

### 递归与 `cascade` 函数的例子

为了更好地理解递归调用的顺序和回溯，让我们来看一个新的例子：**cascade 函数**。这个函数以一种嵌套的方式递归打印出数字。

```python
def cascade(n):
    if n < 10:
        print(n)  # 基准情况：直接打印 n
    else:
        print(n)  # 先打印 n
        cascade(n // 10)  # 递归调用，去掉最后一位
        print(n)  # 再次打印 n
```

当我们调用 `cascade(123)` 时，递归的过程如下：
1. **`cascade(123)`**：首先打印 `123`，然后递归调用 `cascade(12)`。
2. **`cascade(12)`**：打印 `12`，再递归调用 `cascade(1)`。
3. **`cascade(1)`**：基准情况，直接打印 `1`。

之后，递归开始回溯，逐步完成剩下的打印操作：
- `cascade(12)` 再次打印 `12`。
- `cascade(123)` 最后打印 `123`。

输出结果为：
```
123
12
1
12
123
```

### 总结

递归是一种强大的编程方式，通过逐步简化问题并在基准情况下停止递归，然后回溯计算最终结果。理解递归调用的顺序和回溯对于掌握递归的本质至关重要。在许多计算场景中，递归提供了简洁而优雅的解决方案，尽管有时会在效率上受到限制。



### 递归的执行与返回

在递归函数的执行中，每次递归调用都在等待返回值，然后才能继续进行剩余的计算。我们以 `cascade` 函数为例，逐步了解递归的行为和返回顺序。

#### `cascade` 函数定义

```python
def cascade(n):
    if n < 10:
        print(n)  # 基准情况：直接打印 n
    else:
        print(n)  # 先打印 n
        cascade(n // 10)  # 递归调用，去掉最后一位
        print(n)  # 递归返回后再次打印 n
```

这个函数接收一个正整数 `n`，并以一种嵌套的方式递归地打印出数字。基准情况是 `n < 10` 时，直接打印数字。否则，它先打印 `n`，再对 `n // 10` 递归调用 `cascade`，最后在递归返回后再次打印 `n`。

#### 递归调用的顺序与返回

例如，我们调用 `cascade(123)` 时，递归过程如下：

1. **`cascade(123)`**：先打印 `123`，然后递归调用 `cascade(12)`。
2. **`cascade(12)`**：打印 `12`，接着递归调用 `cascade(1)`。
3. **`cascade(1)`**：基准情况，直接打印 `1`。

这时递归达到基准情况，开始回溯：
- **`cascade(12)`** 再次打印 `12`。
- **`cascade(123)`** 最后打印 `123`。

最终的输出结果是：
```
123
12
1
12
123
```

#### 递归返回 `None` 的问题

在递归调用中，如果没有显式的 `return` 语句，函数会自动返回 `None`。例如，当 `cascade(12)` 完成对 `cascade(1)` 的调用后，`cascade(1)` 返回 `None`，这意味着递归已经完成，可以继续执行 `cascade(12)` 剩下的部分。同样，当 `cascade(123)` 完成对 `cascade(12)` 的调用后，`cascade(12)` 返回 `None`，并继续执行 `cascade(123)` 的最后一步。

### 递归与不同的实现方式

我们还可以通过另一种更简洁的方式实现 `cascade` 函数：

```python
def cascade(n):
    print(n)
    if n >= 10:
        cascade(n // 10)
        print(n)
```

这个版本将递归的打印操作集中在一起，减少了冗余代码。在逻辑上，与前一个版本等价，但更加简洁。

#### 简洁与可读性

虽然简洁的代码通常更好，因为它更容易理解和维护，但在学习递归时，较长且分离基准情况和递归情况的实现可能更清晰。因此，初学者在编写递归函数时，建议明确分离基准情况和递归情况，这有助于理解递归的执行流程。

### 逆向级联问题

现在我们要实现一个**逆向级联**的函数，给定一个数字 `n`，依次打印出从最小到最大的递增数字，然后再递减回去。目标是打印以下格式的数字：

```plaintext
1
12
123
1234
123
12
1
```

#### 使用高阶函数的实现思路

我们可以使用 `grow` 和 `shrink` 函数来分别实现递增和递减的打印操作，并结合高阶函数 `cascade_helper`，通过递归实现逆向级联。

```python
def inverse_cascade(n):
    grow(n)
    print(n)
    shrink(n)

def grow(n):
    if n >= 10:
        grow(n // 10)
    print(n)

def shrink(n):
    print(n)
    if n >= 10:
        shrink(n // 10)
```

- **`grow(n)`**：递归地从小到大打印数字。通过 `grow(n // 10)` 逐步缩小数字，直到基准情况，然后开始回溯打印。
- **`shrink(n)`**：递归地从大到小打印数字。先打印当前数字，再调用 `shrink(n // 10)`。

通过这种方式，我们得到了逆向级联的效果。

### 树形递归

递归函数不仅可以进行一次递归调用，还可以进行**多次递归调用**。这就引出了**树形递归**的概念。在树形递归中，一个函数的执行会产生多个递归调用，生成一个树状的递归结构。

#### 树形递归的例子

例如，计算斐波那契数列的递归函数：

```python
def fib(n):
    if n == 0 or n == 1:
        return n
    else:
        return fib(n - 1) + fib(n - 2)
```

在这个函数中，`fib(n)` 同时调用 `fib(n-1)` 和 `fib(n-2)`，形成了树形递归结构。随着 `n` 的增加，递归调用次数成倍增长，因此树形递归的效率较低。

### 总结

递归是解决问题的一种强大方式，特别适合于那些可以分解为子问题的情形。通过递归调用，程序能够简洁优雅地解决复杂的问题。而树形递归则展示了递归可以通过多个调用生成更复杂的递归结构。理解递归调用的顺序、返回值以及如何通过基准情况终止递归，是掌握递归编程的关键。





### 树形递归 (Tree Recursion)

**树形递归**发生在一个函数在其主体中调用了不止一次自身的情况。这种递归会产生树状的计算过程，常见的例子是计算**斐波那契数列**。

### 斐波那契数列

斐波那契数列的定义如下：
- 第 0 个斐波那契数是 0，记为 F(0) = 0。
- 第 1 个斐波那契数是 1，记为 F(1) = 1。
- 对于 n ≥ 2，F(n) = F(n-1) + F(n-2)。

所以，斐波那契数列从零开始：
```
F(0) = 0, F(1) = 1, F(2) = 1, F(3) = 2, F(4) = 3, F(5) = 5, F(6) = 8, F(7) = 13, F(8) = 21, F(9) = 34, F(10) = 55, ...
```

### 树形递归计算斐波那契数

斐波那契数列的计算可以用树形递归实现。代码如下：

```python
def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)
```

在这个实现中：
- 当 `n = 0` 或 `n = 1` 时，直接返回已知的结果（基准情况）。
- 当 `n > 1` 时，通过递归调用 `fib(n-1)` 和 `fib(n-2)`，计算前两个斐波那契数之和。

这是树形递归，因为每次递归调用 `fib(n)` 都会进一步调用 `fib(n-1)` 和 `fib(n-2)`，形成树状的递归调用结构。

### 计算过程

例如，计算 `fib(5)` 时，调用过程如下：

```
fib(5)
│
├─ fib(4)
│  ├─ fib(3)
│  │  ├─ fib(2)
│  │  │  ├─ fib(1) = 1
│  │  │  └─ fib(0) = 0
│  │  └─ fib(2) 返回 1
│  ├─ fib(2)
│  │  ├─ fib(1) = 1
│  │  └─ fib(0) = 0
│  └─ fib(3) 返回 2
└─ fib(4) 返回 3
```

- `fib(5)` 调用 `fib(4)` 和 `fib(3)`。
- `fib(4)` 再调用 `fib(3)` 和 `fib(2)`，依次递归下去，直到基准情况。

整个计算过程构成一棵递归调用的树，根节点是 `fib(5)`，每个节点依次展开调用前两个斐波那契数。

### 树形递归的效率问题

虽然树形递归可以正确计算斐波那契数，但它的效率非常低。原因在于，树形递归中许多计算是重复的。例如，在计算 `fib(5)` 时，`fib(3)` 被计算了两次，`fib(2)` 也被计算了多次。

由于递归调用次数随着 `n` 的增加呈指数增长，所以当 `n` 较大时，这种实现方式会非常慢。例如，计算 `fib(35)` 时，尽管斐波那契数列的增长相对较快，但计算耗时较长。对每一个 `n`，函数会重复计算很多次之前已经计算过的斐波那契数。

### 优化树形递归：记忆化 (Memoization)

为了解决这个效率问题，可以通过**记忆化**（Memoization）来优化。记忆化是一种缓存技术，用于存储已经计算过的结果，避免重复计算。

实现记忆化的递归斐波那契函数如下：

```python
def fib_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n == 0:
        result = 0
    elif n == 1:
        result = 1
    else:
        result = fib_memo(n - 1, memo) + fib_memo(n - 2, memo)
    memo[n] = result
    return result
```

- `memo` 是一个字典，用于存储已经计算过的斐波那契数。
- 每次递归调用前，检查 `n` 是否已经在 `memo` 中，如果在，直接返回结果；否则，继续递归计算并将结果存入 `memo`。

这样一来，每个斐波那契数只会计算一次，极大提高了效率。

### 总结

树形递归是递归的一种形式，它通过多次递归调用形成树状结构。斐波那契数列的递归计算是树形递归的经典例子，但由于大量的重复计算，效率较低。通过记忆化等技术可以优化递归函数，使其性能显著提升。在实际编程中，根据问题的特点选择合适的递归实现方式和优化技术至关重要。



我们在前面介绍了递归的概念，并通过 Fibonacci 数列和其他例子展示了树形递归的执行过程。接下来，我们将讨论另一个经典的递归问题：**汉诺塔问题（Towers of Hanoi）**。

### 汉诺塔问题简介

汉诺塔问题是一个非常著名的递归问题。游戏的规则很简单：
1. 你有三个柱子和若干个大小不一的圆盘，这些圆盘最初按照从大到小的顺序堆叠在第一个柱子上，形成一个塔状结构。
2. 你的目标是将整个塔从第一个柱子移动到第三个柱子。
3. 每次只能移动一个圆盘，并且在任何时候都不能将较大的圆盘放在较小的圆盘上。

### 汉诺塔问题的递归解法

递归解决汉诺塔问题非常自然，以下是解决步骤：
1. 将 `n-1` 个圆盘从第一个柱子移动到第二个柱子。
2. 将第 `n` 个（即最大的）圆盘从第一个柱子移动到第三个柱子。
3. 最后，将之前的 `n-1` 个圆盘从第二个柱子移动到第三个柱子。

通过这种递归分解，我们可以将一个复杂的问题分解为多个相对简单的子问题。对于基本情况，当只有一个圆盘时，直接将圆盘从起始柱子移动到目标柱子即可。

### 汉诺塔问题的递归 Python 实现

```python
def hanoi(n, source, target, auxiliary):
    if n == 1:
        print(f"Move disk 1 from {source} to {target}")
    else:
        hanoi(n - 1, source, auxiliary, target)  # Step 1: 将 n-1 个圆盘从源柱移动到辅助柱
        print(f"Move disk {n} from {source} to {target}")  # Step 2: 将第 n 个圆盘从源柱移动到目标柱
        hanoi(n - 1, auxiliary, target, source)  # Step 3: 将 n-1 个圆盘从辅助柱移动到目标柱
```

在这个递归实现中：
- `n` 表示圆盘的数量。
- `source` 是初始柱子。
- `target` 是目标柱子。
- `auxiliary` 是辅助柱子。

### 执行过程

假设有 3 个圆盘，那么执行过程如下：

```text
Move disk 1 from A to C
Move disk 2 from A to B
Move disk 1 from C to B
Move disk 3 from A to C
Move disk 1 from B to A
Move disk 2 from B to C
Move disk 1 from A to C
```

这里我们遵循递归步骤，将较小的子问题分解并最终解决整个问题。随着 `n` 的增加，递归调用的层次会逐渐增多，问题的规模会成倍增长。

### 汉诺塔的递归深度与时间复杂度

汉诺塔问题的递归深度是 `n`，即圆盘的数量，而移动的总步数是 `2^n - 1`，因此时间复杂度为 O(2^n)。这意味着对于较大的 `n`，计算量会急剧增加，这也是递归方法在处理大规模问题时的一个重要特征。

### 总结

汉诺塔问题是递归的一个经典应用，展示了如何通过递归将复杂的问题分解为多个较小的子问题来解决。通过递归，我们可以轻松地解决这种看似复杂的问题，而通过理解递归的执行过程和递归树，我们也能够深入理解递归的强大和潜在的效率问题。在实际编程中，递归为我们提供了一种简洁优雅的解题思路，但同时需要警惕递归深度和性能开销。





我们通过递归实现了 **汉诺塔（Towers of Hanoi）** 问题的解决过程。现在我们来详细理解这个过程，并看它是如何一步一步地展开和执行的。

### 递归实现解析

在递归调用中，每个调用都是对更简单问题的求解。具体地说，若我们要移动 `n` 个盘子从起始柱子到目标柱子，我们需要做三件事：
1. 递归地将 `n-1` 个盘子从起始柱子移动到辅助柱子。
2. 将第 `n` 个盘子从起始柱子移动到目标柱子。
3. 递归地将 `n-1` 个盘子从辅助柱子移动到目标柱子。

**代码实现：**

```python
def hanoi(n, source, target, auxiliary):
    if n == 1:
        print(f"Move disk 1 from {source} to {target}")
    else:
        hanoi(n - 1, source, auxiliary, target)  # 第一步：将 n-1 个盘子移动到辅助柱子
        print(f"Move disk {n} from {source} to {target}")  # 第二步：移动第 n 个盘子到目标柱子
        hanoi(n - 1, auxiliary, target, source)  # 第三步：将 n-1 个盘子从辅助柱子移动到目标柱子
```

### 案例分析：三层汉诺塔

假设我们有 3 个盘子，起始柱子是 1，目标柱子是 2，辅助柱子是 3。我们希望将 3 个盘子从柱子 1 移动到柱子 2：

1. 首先，我们递归调用 `hanoi(2, 1, 3, 2)`，这是将前两个盘子从 1 移动到辅助柱子 3。
   - 再次递归调用 `hanoi(1, 1, 2, 3)`，将盘子 1 从 1 移动到 2（这是基础情况，直接打印）。
   - 然后移动盘子 2 从 1 到 3。
   - 之后，递归调用 `hanoi(1, 2, 3, 1)`，将盘子 1 从 2 移动到 3。

   此时，前两个盘子已经从起始柱子 1 移动到了辅助柱子 3。

2. 现在，我们移动盘子 3（最大的盘子）从 1 到目标柱子 2。

3. 接着，递归调用 `hanoi(2, 3, 2, 1)`，将两个盘子从辅助柱子 3 移动到目标柱子 2。
   - 递归调用 `hanoi(1, 3, 1, 2)`，将盘子 1 从 3 移动到 1。
   - 然后移动盘子 2 从 3 到 2。
   - 最后，递归调用 `hanoi(1, 1, 2, 3)`，将盘子 1 从 1 移动到 2。

整个过程完成。

### 递归流程解释

递归的核心在于逐步简化问题的规模，直到达到可以直接解决的基本情况。在汉诺塔问题中，递归调用通过不断减少盘子的数量，最终归结到只需移动一个盘子的情况（即基础情况）。

每次递归调用的关键点在于：
1. 将问题分解为更小的子问题（`n-1` 个盘子的移动）。
2. 利用辅助柱子完成中间步骤。
3. 递归调用结束后，回溯并完成整个问题的解。

### 递归调用堆栈的特性

正如我们在代码解析中看到的，递归调用会形成一个调用栈。每一次递归都会将当前问题压入栈中，直到达到基本情况为止，然后再逐层返回，解决先前的问题。这个递归调用栈的特性使得我们可以方便地解决类似汉诺塔这样的问题。

### 总结

递归在解决汉诺塔问题时显得非常优雅。它通过将复杂的问题拆解为多个较小的子问题，并逐步求解，最终完成整个问题。递归是一种强大的编程技巧，特别适用于像汉诺塔这样具有分解特性的问题。在实际编程中，我们经常使用递归来简化复杂的算法问题，并通过递归调用栈来确保每一步都得到正确的执行。



**塔汉诺塔（Towers of Hanoi）** 是一个经典的递归问题，通过分析它，我们可以深入理解递归的力量和计算复杂度背后的理论。下面对刚才讨论内容做一个总结和分析。

### 汉诺塔问题的递归求解

汉诺塔问题递归的核心思想是：通过将问题简化为更小的子问题，我们可以逐步解决整个问题。具体步骤如下：
1. **将 `n-1` 个盘子从起始柱子移动到辅助柱子**。这是一个递归调用，因为我们再次遇到了相同的问题，只不过规模缩小了（`n-1` 个盘子）。
2. **将第 `n` 个盘子从起始柱子移动到目标柱子**。这是当前步骤的核心目标，也是递归的“返回”步骤之一。
3. **将 `n-1` 个盘子从辅助柱子移动到目标柱子**。这也是递归调用的一部分，最终完成整个移动过程。

通过递归，我们将复杂的多盘移动问题分解为一系列较小的步骤，直到最后到达基本情况，即只需移动一个盘子。这个基本情况是递归中的终止条件。

### 递归调用的执行流程

每次递归调用都会创建一个新的函数调用栈，当递归调用返回时，控制权回到前一个调用点。对于汉诺塔问题，我们使用了两个递归调用：
- 第一次调用是为了将 `n-1` 个盘子移动到辅助柱子；
- 第二次调用是为了将 `n-1` 个盘子从辅助柱子移动到目标柱子。

这些调用会不断嵌套，直到遇到基本情况。

### 递归调用的效率分析

递归带来的问题之一是计算量的指数增长。每次添加一个盘子，所需的步骤数量几乎翻倍，这是因为：
1. 每增加一个盘子，涉及到的递归调用数量也随之增加。
2. 为了移动 `n` 个盘子，递归调用必须两次处理 `n-1` 个盘子的移动。

这种递归模式的复杂度是 **指数级的**。通过观察：
- 移动 1 个盘子只需 1 步；
- 移动 2 个盘子需要 3 步；
- 移动 3 个盘子需要 7 步；
- 移动 4 个盘子需要 15 步；
- 移动 5 个盘子需要 31 步；
可以看出步骤数每次大约翻倍。这种指数增长在数学上可以表示为：移动 `n` 个盘子的最小步骤数是 `2^n - 1`。

### 指数增长的影响

这种指数增长在计算中非常昂贵，尤其当盘子的数量增加时。比如，对于 64 个盘子的汉诺塔问题，所需的移动次数是 `2^64 - 1`，这显然是一个巨大的数字，几乎不可能在现实中处理。因此，递归虽然能够提供一个简单优雅的解法，但在这种场景下，其效率并不理想。

**指数增长** 是计算中一个非常重要的概念，它告诉我们算法的增长速度以及其可扩展性。在某些安全应用场景下，比如密码学中，指数增长是我们所期望的，因为它能提供足够的计算难度来保护系统不被暴力破解。然而，在实际问题求解中，指数增长往往是我们需要避免的，因为它会导致计算时间和资源的急剧增加。

### 递归与迭代的权衡

递归并不是解决所有问题的唯一方式。在设计算法时，我们应该权衡递归与迭代的使用。递归能够简化问题的分解，并提供优雅的解法，但它的效率有时会受到限制。在有些情况下，迭代方法可能更高效，尤其当问题规模较大时。

在汉诺塔问题中，递归展示了其优雅之处，我们通过简单的递归调用解决了一个复杂的多步问题。然而，伴随递归的还有性能上的代价。这提醒我们在设计和选择算法时，既要考虑解法的简洁性，也要考虑算法的效率和适用场景。

### 递归的启示

1. **递归的威力**：递归能够通过分解问题，逐步解决复杂问题。汉诺塔问题展示了递归的强大和优雅。
2. **计算复杂度**：递归往往伴随复杂度的增长。在汉诺塔问题中，递归的计算复杂度呈现指数级增长。
3. **设计决策**：递归并非适用于所有场景。设计解决方案时，应根据具体问题选择合适的方法。

### 结语

通过汉诺塔问题，我们不仅看到了递归的强大，还引出了算法复杂度的重要性。在实际编程中，递归和迭代各有优劣，如何选择取决于具体问题。未来，在学习更复杂的算法和数据结构时，递归和复杂度分析将更加频繁地出现，帮助我们设计出更高效的解决方案。



### 递归与分区计数问题

在递归概念的延续下，我们引入了 **分区计数问题（Counting Partitions）**。这个问题展示了递归如何帮助解决复杂的组合问题，并且是递归在某些情况下比迭代更优雅和有效的一个具体例子。

#### 分区计数问题的定义

对于一个正整数 `n` 和一个最大部分 `m`，问题要求计算所有可能的方式将 `n` 分解为多个部分，并且每个部分的大小不能超过 `m`，且分解后的部分要按非递减顺序排列。

例如：
- 对于 `n = 6` 和 `m = 4`，分区的方式有：
  - `2 + 4`
  - `1 + 1 + 4`
  - `1 + 2 + 3`
  - `3 + 3`
  - 等等……

这样一共有 9 种不同的分区方式。

#### 递归解法的思想

为了计算 `count_partitions(n, m)`，可以通过递归将问题简化。递归的核心是将问题分解为两个互斥的子问题：
1. **包含至少一个 `m` 的分区**：这种情况下，我们可以将问题转化为计算 `count_partitions(n - m, m)`，即计算 `n - m` 的分区数量，使用的最大部分仍为 `m`。
2. **不包含 `m` 的分区**：这种情况下，我们计算的是 `count_partitions(n, m - 1)`，即不使用 `m`，只使用最大为 `m - 1` 的部分。

#### 递归的思路

递归的核心在于：
- 如果我们使用了一个 `m`，那么问题就变成了如何将剩下的 `n - m` 进行分区。
- 如果我们不使用 `m`，问题就变成如何将 `n` 仅用最大部分为 `m - 1` 的数字进行分区。

通过这两种递归调用，最终我们会得到问题的解。这个递归解法是树形递归的一个典型例子，其中每个递归调用会引发两个进一步的递归调用，类似于一棵二叉树逐层展开。

#### 代码实现

我们可以使用 Python 实现这个递归的分区计数算法：

```python
def count_partitions(n, m):
    # 基本情况
    if n == 0:
        return 1  # 找到一个有效分区
    elif n < 0 or m == 0:
        return 0  # 无效分区
    
    # 递归调用：包含 m 或不包含 m
    return count_partitions(n - m, m) + count_partitions(n, m - 1)
```

#### 代码解析
- 当 `n == 0` 时，表示我们已经找到了一种有效的分区方式，因此返回 `1`。
- 如果 `n < 0` 或者 `m == 0`，表示当前分区不可能，因此返回 `0`。
- 递归的核心是分别处理“包含 `m`”和“不包含 `m`”的两种情况，最终将这两部分的结果相加，得到总的分区数量。

#### 分区计数的计算流程

假设我们要计算 `count_partitions(6, 4)`：
- 第一步，考虑包含至少一个 `4`，问题转化为 `count_partitions(2, 4)`。
- 第二步，考虑不包含 `4`，问题转化为 `count_partitions(6, 3)`。

然后再递归地解决这些子问题，直到达到基本情况 `n == 0` 或者 `m == 0`。

#### 树形递归的优势

树形递归在解决这类组合问题时非常强大，因为它能够系统地探索所有可能的选择。每次递归调用都会进一步缩小问题规模，直到达到基本情况。尽管树形递归的效率可能不如某些优化的动态规划算法，但它提供了一个简洁优雅的解法，尤其在处理类似分区计数这样复杂的组合问题时。

#### 总结

- 递归是解决问题的一种强大工具，特别是在需要系统地探索所有可能选择的情况下，例如分区计数问题。
- 分区计数问题展示了如何使用树形递归来简化复杂问题，通过逐步将问题分解为更小的子问题，直到达到基本情况。
- 尽管递归有时可能效率较低，但它的优雅性和简单性使得它在特定场景下成为了首选。

接下来，我们将从递归转向**面向对象编程（Object-Oriented Programming, OOP）**，进入 Python 编程的一个全新章节。在这一部分，我们不仅会关注如何使用函数来进行计算，还会学习如何通过类和对象来管理和组织数据，解决更复杂的问题。





### 分区计数的递归实现

在前面的讨论中，我们探讨了如何使用递归来解决分区计数问题。核心思路是通过递归地将问题分解为更简单的实例来计算最终的结果。

#### 递归的思想
假设我们需要计算 `count_partitions(n, m)`，即将数字 `n` 使用不大于 `m` 的部分进行分区。我们将问题分解为两个互斥的子问题：
1. **包含至少一个大小为 `m` 的部分**：这意味着我们将问题简化为 `count_partitions(n - m, m)`，即计算剩余部分 `n - m` 的分区，允许使用的部分仍为大小不超过 `m`。
2. **不包含大小为 `m` 的部分**：我们将问题转化为 `count_partitions(n, m - 1)`，即不使用大小为 `m` 的部分，仅使用大小不超过 `m - 1` 的部分进行分区。

这两个子问题涵盖了所有可能的分区情况，因此可以通过将它们的结果相加，得到最终的答案。

#### 递归的分解过程
例如，计算 `count_partitions(6, 4)`：
1. 包含至少一个 `4` 的分区，问题转化为 `count_partitions(2, 4)`。
2. 不包含 `4` 的分区，问题转化为 `count_partitions(6, 3)`。

然后递归地解决这些子问题，直到达到基本情况。

#### 代码实现

以下是 Python 中的递归实现：

```python
def count_partitions(n, m):
    # 基本情况：n 为 0 时，只有一种方式，即不添加任何部分
    if n == 0:
        return 1
    # 基本情况：n 小于 0 或 m 为 0 时，没有有效的分区方式
    elif n < 0 or m == 0:
        return 0
    else:
        # 递归调用：包含 m 和 不包含 m 的两种情况
        return count_partitions(n - m, m) + count_partitions(n, m - 1)
```

#### 基本情况解释：
1. **`n == 0`**：表示我们找到了一个有效的分区方式，即不再添加部分。
2. **`n < 0` 或 `m == 0`**：表示无效分区，例如，无法将负数进行分区，或者没有可用的部分时无法分区。

#### 测试代码

让我们通过一些实例来测试这个递归函数：

```python
print(count_partitions(6, 4))  # 输出 9
print(count_partitions(5, 3))  # 输出 5
```

在 `count_partitions(5, 3)` 中，递归过程如下：
1. **包含 `3` 的分区**：问题转化为 `count_partitions(2, 3)`。
   - 计算 `count_partitions(2, 3)`：
     1. 包含 `3` 的情况：`count_partitions(-1, 3)`，无效，返回 `0`。
     2. 不包含 `3` 的情况：`count_partitions(2, 2)`，返回 `2`（`1+1` 和 `2`）。
2. **不包含 `3` 的分区**：问题转化为 `count_partitions(5, 2)`。
   - 计算 `count_partitions(5, 2)`：
     1. 包含 `2` 的情况：`count_partitions(3, 2)`，返回 `2`（`1+1+1` 和 `1+2`）。
     2. 不包含 `2` 的情况：`count_partitions(5, 1)`，返回 `1`（`1+1+1+1+1`）。

最终结果为 `2 + 3 = 5`。

### 递归的优势与总结

- 递归是一种强大的技术，尤其在解决组合问题时，它可以帮助系统地探索所有可能的选择。
- 分区计数问题展示了递归如何简化复杂问题，通过递归地将问题分解为更小的子问题来找到最终解。
- 尽管递归有时效率较低，但它提供了一种简洁优雅的解法，尤其适用于处理像分区计数这样的组合问题。

通过这个问题，我们能够更深入地理解树形递归的工作原理，并且学会如何通过递归来解决复杂的分区问题。



