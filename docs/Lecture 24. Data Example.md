# Lecture 24. Data Example

### 作业与考试相关安排

1. **作业提交与加分机会**  
   - **Homework 5** 需要在周一前提交，但如果在周四之前提前提交，可以获得额外的加分。  
   - Lab 9 的唯一必做内容是完成 Homework 5，因此可以用平时完成实验的时间来完成该作业。实验 9 也包含一些可选问题，会作为期中考试的良好练习。实验 9 将附带解决方案，更多是作为学习辅助工具。

2. **期中考试准备**  
   - **期中考试二** 临近，有多种备考方式可供选择。  
     - 可以回看课程讲座视频，或者做过去实验中的可选题目。  
     - 学生小组 CS Mentors 和 HKN 将分别在周六和周日举行复习讲座，CS Mentors 的复习时间为周六中午和下午 6 点，HKN 的复习时间为周日下午 4 点，所有讲座均会录制。  
     - 教师团队将在周一上午 11 点开始提供一份模拟考试，考试内容来自 2020 年春季的期中考试二，题目格式与实际考试一致。模拟考试可以在任何时间完成，用于熟悉考试环境和软件。  
     - Piazza 上发布了一些与课堂讨论相关的往期考试题目及其讲解视频的链接，供复习参考。  
     - 期中考试二的复习指南和备考文档已准备好，可以在复习时参考。

3. **期中考试规则与安排**  
   - 考试将于 **下周三晚 7 点** 开始，监考方式将通过视频进行，视频中需要包含考生的头部和屏幕。若希望申请监考豁免，需在周日前提交表格申请。  
   - 如果有需要在不同时间参加考试的需求，请提交替代时间申请表。

### 课程日程与内容调整

1. **学生反馈与内容调整**  
   - 由于不少学生反馈在远程学习环境中感到压力过大，课程团队对内容进行了调整。课程的某些内容，例如二进制数和电路，不会在考试中涉及，仅作为拓展内容，旨在提供一些有趣的学习材料，而不增加学习负担。  
   - 未来两周将有两次可选讲座，分别在周一和周五，主要任务是完成 Homework 5 和期中考试。期中考试结束后将不会再引入新的必修内容。

2. **可选讲座与减少的学习压力**  
   - 未来某些讲座内容将变为可选，并且不会出现在期末考试或作业中。这些可选内容包括宏与尾调用的讲座以及数据库的讲座。学生可以选择学习这些内容，但不会对最终成绩产生影响。

### 面向对象系统的示例

1. **属性查找规则**  
   - 当通过实例名称查找属性时，首先查找的是实例属性，其次是类属性。如果实例中未找到，则会查找类中的属性，如果类中也没有找到，则继续在父类中查找。这种机制使得类属性可以被继承。

2. **示例：Worker 类**  
   ```python
   class Worker:
       greeting = "sir"
   
       def __init__(self, elf):
           self.elf = elf
   
       def work(self):
           return self.greeting + ", I work"
   
       def __repr__(self):
           return f"Worker(elf={self.elf})"
   ```

   - **属性解释**：
     - `greeting`: 这是类属性，所有 `Worker` 实例都共享这个属性，默认为 "sir"。
     - `__init__`: 构造函数，用于初始化实例属性 `elf`。
     - `work`: 实例方法，返回对象的问候语以及 "I work" 字符串。
     - `__repr__`: 特殊方法，用于控制实例的字符串表示。

   - **继承规则**：  
     当实例中没有定义某个属性时，会自动查找类中的属性，若类中也没有则查找父类，这就是类属性继承的机制。



### 课程内容：对象系统与属性查找详解

#### 构造函数与属性赋值
首先，我们定义了一个 `Worker` 类，该类包含以下元素：
- **构造函数**：`__init__` 方法中将一个名为 `elf` 的属性赋值为 `Worker` 类的引用。这意味着，每个创建的 `Worker` 实例都拥有一个指向 `Worker` 类的 `elf` 属性。
- **方法**：
  - `work()` 方法：返回对象的 `greeting` 属性值加上字符串 `" I work"`。 
  - `__repr__()` 方法：在交互式会话中，输出类实例的字符串表示。

#### 示例：`Worker` 与 `Bourgeoisie` 类
1. 定义 `Worker` 类后，我们还创建了一个继承自 `Worker` 的 `Bourgeoisie` 类。该类覆盖了 `greeting` 属性，将其值设为 `"Peon"`。这意味着 `Bourgeoisie` 类的实例在调用 `work()` 方法时，会显示与 `Worker` 类不同的 `greeting` 值。

2. 创建了两个实例：
   - `jack = Worker()`：`jack` 是 `Worker` 类的实例，其 `greeting` 属性默认为 `"Sir"`。
   - `john = Bourgeoisie()`：`john` 是 `Bourgeoisie` 类的实例，继承了 `Worker` 类的 `__init__` 方法，但其 `greeting` 属性为 `"Peon"`。

#### 属性查找规则
- 当访问 `jack.greeting` 时，系统会先检查 `jack` 实例自身是否有 `greeting` 属性。如果没有，则会查找 `Worker` 类的 `greeting`，该值为 `"Sir"`。
- **属性赋值规则**：当对 `jack.greeting` 进行赋值时，例如 `jack.greeting = "Ma'am"`，该操作会直接在 `jack` 实例中创建一个新的 `greeting` 属性，而不会修改 `Worker` 类中的 `greeting` 属性。因此，此时 `jack.greeting` 为 `"Ma'am"`，而其他 `Worker` 实例的 `greeting` 仍然是 `"Sir"`。

#### 示例代码及解释
```python
class Worker:
    greeting = "Sir"
    
    def __init__(self):
        self.elf = Worker
    
    def work(self):
        return self.greeting + " I work"
    
    def __repr__(self):
        return "Peon"
    
class Bourgeoisie(Worker):
    greeting = "Peon"
```

##### 执行流程
1. **`jack.greeting = "Ma'am"`**：
   - `jack` 实例的 `greeting` 属性被设置为 `"Ma'am"`，而不影响 `Worker` 类的 `greeting`。
   
2. **调用 `work()` 方法**：
   - 对于 `jack.work()`：
     - 查找 `greeting`，由于 `jack` 实例有自己的 `greeting`，其值为 `"Ma'am"`，因此返回 `"Ma'am I work"`。
   - 对于 `john.work()`：
     - `john` 是 `Bourgeoisie` 类的实例，继承了 `Worker` 类的 `work()` 方法。`john` 没有自己的 `greeting` 属性，因此从 `Bourgeoisie` 类中查找，返回 `"Peon I work"`。

3. **`__repr__()` 方法**：
   - `jack` 的 `__repr__()` 方法返回 `"Peon"`，因为 `Worker` 类的 `__repr__()` 方法在交互式会话中被调用，用来表示实例的字符串形式。

#### 复杂示例：调用链与继承机制
在调用 `john.work()` 时，首先会调用 `Bourgeoisie` 类的 `work()` 方法，实际上它是从 `Worker` 类继承而来。此时，会根据 `john` 的 `greeting` 值（在 `Bourgeoisie` 类中为 `"Peon"`）返回 `"Peon I work"`，然后调用 `repr()` 方法返回 `"I gather wealth"`。

#### 总结
- **类与实例的属性查找顺序**：首先从实例中查找，如果实例中没有该属性，则继续查找类属性；如果类中也没有，则查找基类的属性。
- **方法继承与调用**：子类可以继承父类的方法，并在子类中覆盖父类的属性，如 `Bourgeoisie` 类中的 `greeting`。



### 示例讲解：迭代器与列表解析、字典解析的应用

接下来，我们来看几个通过列表解析、字典解析和内置函数实现的复杂数据操作示例。

#### 1. **找到列表中绝对值最小的元素的索引**
   给定一个列表 `s`，我们要找到所有具有最小绝对值的元素的索引。例如，列表 `s = [3, -2, 5, 7, 2]` 中，绝对值最小的元素是 `-2` 和 `2`，它们的索引分别为 1 和 4。

   **解决思路**：
   - 首先，计算列表中每个元素的绝对值，并找到最小的绝对值。
   - 然后，通过列表解析，找到与该最小绝对值相等的元素的索引。

   **代码实现**：
   ```python
   s = [3, -2, 5, 7, 2]
   min_abs_value = min(map(abs, s))  # 计算最小绝对值
   indices = [i for i in range(len(s)) if abs(s[i]) == min_abs_value]  # 找到对应索引
   print(indices)  # 输出：[1, 4]
   ```

   **解释**：
   - `min(map(abs, s))` 计算列表 `s` 中元素的最小绝对值。
   - 使用列表解析 `[i for i in range(len(s)) if abs(s[i]) == min_abs_value]` 找到绝对值等于最小值的索引。

#### 2. **计算列表中相邻两个元素的最大和**
   给定一个列表 `s`，找到其中相邻两个元素的最大和。例如，`s = [1, -3, 4, -2, 5]`，相邻元素最大和是 `4 + (-2) = 6`。

   **解决思路**：
   - 遍历列表中的相邻元素对，计算它们的和，然后取最大值。

   **代码实现**：
   ```python
   s = [1, -3, 4, -2, 5]
   max_sum = max(s[i] + s[i+1] for i in range(len(s)-1))  # 计算相邻元素和的最大值
   print(max_sum)  # 输出：6
   ```

   **解释**：
   - 使用列表解析计算相邻元素的和，`s[i] + s[i+1]` 表示相邻元素对的和，然后使用 `max()` 函数取出最大值。

#### 3. **创建一个字典，映射每个数字 d 到列表中以 d 结尾的元素**
   给定一个整数列表 `s`，创建一个字典，键为 0-9 的数字，值为以该数字结尾的元素列表。例如，`s = [15, 25, 33, 42, 55, 68, 99]`，输出的字典为：
   ```python
   {1: [], 2: [42], 3: [33], 5: [15, 25, 55], 8: [68], 9: [99]}
   ```

   **解决思路**：
   - 遍历列表中的每个元素，获取其最后一位数字，按照该数字将元素分类存储在字典中。

   **代码实现**：
   ```python
   s = [15, 25, 33, 42, 55, 68, 99]
   digit_map = {d: [x for x in s if x % 10 == d] for d in range(10)}  # 创建字典映射
   print(digit_map)
   ```

   **解释**：
   - 使用字典解析 `{d: [x for x in s if x % 10 == d] for d in range(10)}` 将每个元素按照其末尾数字进行分类，`x % 10` 用来获取元素的最后一位数字。

#### 4. **检查列表中每个元素是否都有重复项**
   给定一个列表 `s`，检查是否每个元素都有重复项。例如，`s = [-4, 4, 3, 2, 4, 3, 2]`，此时每个元素都有重复项，返回 `True`；如果 `s = [-4, 4, 3, 2]`，由于 `-4` 没有重复，返回 `False`。

   **解决思路**：
   - 对于每个元素，检查列表中该元素的出现次数是否大于 1。

   **代码实现**：
   ```python
   s = [-4, 4, 3, 2, 4, 3, 2]
   all_have_duplicates = all(s.count(x) > 1 for x in s)  # 检查每个元素是否有重复
   print(all_have_duplicates)  # 输出：True
   ```

   **解释**：
   - 使用 `s.count(x)` 计算列表中每个元素 `x` 的出现次数，`all()` 函数检查是否所有元素的出现次数都大于 1。

### 总结
- 通过列表解析、字典解析和内置函数，我们可以在一行或两行代码中实现复杂的数据操作。
- 这些方法不仅简洁，而且在处理迭代和集合操作时非常高效，在编写高效 Python 代码时非常实用。



### 列表中相邻元素的最大和
这个问题要求我们找到列表中相邻两个元素的最大和。假设给定一个列表 `s`，我们需要计算所有相邻元素对的和，然后返回其中的最大值。例如，`s = [1, -3, 4, -2, 5]`，相邻元素的最大和是 `4 + (-2) = 6`。

#### 方法1：通过索引遍历
1. 我们可以通过索引遍历 `s`，计算相邻元素的和，排除最后一个元素以避免越界错误。
2. 使用 `max()` 函数找到所有相邻元素和中的最大值。

**代码实现：**
```python
s = [1, -3, 4, -2, 5]
max_sum = max(s[i] + s[i+1] for i in range(len(s)-1))  # 遍历相邻元素对并求和
print(max_sum)  # 输出：6
```

**解释**：
- `range(len(s)-1)` 生成从0到列表倒数第二个元素的索引，确保我们计算 `s[i] + s[i+1]` 不会越界。
- `max()` 函数返回所有相邻元素和中的最大值。

#### 方法2：使用 `zip()` 函数
1. 我们可以使用 `zip()` 将列表 `s` 的元素与其偏移一个位置的元素配对，从而获得相邻元素对。
2. 然后我们可以对这些配对的元素求和，最终使用 `max()` 找到最大值。

**代码实现：**
```python
s = [1, -3, 4, -2, 5]
max_sum = max(a + b for a, b in zip(s, s[1:]))  # 使用 zip 将相邻元素配对
print(max_sum)  # 输出：6
```

**解释**：
- `zip(s, s[1:])` 将 `s` 列表与它的偏移版本 `s[1:]` 配对，生成所有相邻元素对。
- `max(a + b for a, b in zip(s, s[1:]))` 计算相邻元素的和，并返回其中的最大值。

### 使用字典解析处理列表元素
问题要求将每个数字映射到以该数字结尾的列表元素。假设我们有一个整数列表 `s = [15, 25, 33, 42, 55, 68, 99]`，我们要生成一个字典，其中键为0到9的数字，值为以该数字结尾的元素列表。

#### 解决思路
1. 我们可以使用字典解析 (`dict comprehension`)，对于每个数字 `d`，检查列表 `s` 中所有以该数字结尾的元素。
2. 使用 `x % 10` 获取数字的最后一位，过滤出符合条件的元素。

**代码实现：**
```python
s = [15, 25, 33, 42, 55, 68, 99]
digit_map = {d: [x for x in s if x % 10 == d] for d in range(10)}  # 使用字典解析映射数字到列表元素
print(digit_map)
```

**输出**：
```python
{0: [], 1: [], 2: [42], 3: [33], 4: [], 5: [15, 25, 55], 6: [], 7: [], 8: [68], 9: [99]}
```

**解释**：
- `{d: [x for x in s if x % 10 == d] for d in range(10)}` 遍历0到9的每个数字 `d`，并在 `s` 中找到所有以该数字结尾的元素，生成字典。

### 列表中每个元素是否有重复
问题是：列表 `s` 中的每个元素是否至少有一个重复的元素。例如，对于列表 `s = [-4, 4, 3, 2, 4, 3, 2]`，所有元素都有至少一个重复项，结果为 `True`。

#### 解决思路
1. 对于每个元素，检查它在列表中的出现次数，若大于1则该元素有重复。
2. 我们可以使用 `all()` 函数结合列表解析来实现。

**代码实现：**
```python
s = [-4, 4, 3, 2, 4, 3, 2]
all_have_duplicates = all(s.count(x) > 1 for x in s)  # 检查每个元素是否有重复
print(all_have_duplicates)  # 输出：True
```

**解释**：
- `s.count(x)` 返回元素 `x` 在列表中的出现次数。
- `all()` 函数检查列表中是否所有元素的出现次数都大于1。

### 总结
- 通过索引和 `zip()` 可以轻松解决相邻元素问题。
- 字典解析和列表解析可以在一行代码中处理复杂的数据操作。
- 这些方法非常适合处理迭代器和序列的操作，是高效 Python 编程的基本工具。





### 计数与列表解析：简化问题

在上面的讨论中，我们不关心列表中具体某个值出现的次数（例如 "3" 出现了多少次），而是关心每个值是否至少出现了两次。因此，目标是确定列表 `s` 中每个值是否都有至少一个重复项。为此，我们可以使用 `s.count(x)` 来获取元素 `x` 在列表中的出现次数。

#### 最简单的解决方案
通过使用 `count()` 方法，我们可以轻松解决这个问题，只需检查列表中每个元素的出现次数是否大于1即可。如果所有元素的出现次数都大于1，那么说明每个元素都有重复项。

**代码实现：**
```python
s = [4, 4, 3, 3, 2, 2]
all_have_duplicates = all(s.count(x) > 1 for x in s)  # 检查每个元素是否有重复
print(all_have_duplicates)  # 输出：True
```

**解释**：
- `s.count(x)` 返回元素 `x` 在列表中的出现次数。
- `all()` 函数检查是否所有元素的出现次数都大于1，若是，则返回 `True`。

#### 优化思路
这个方法的计算复杂度是 O(n^2)，因为 `count()` 方法需要对列表进行遍历。我们可以通过使用 `collections.Counter` 优化这一过程，将时间复杂度降为 O(n)。

**代码优化：**
```python
from collections import Counter

s = [4, 4, 3, 3, 2, 2]
counts = Counter(s)  # 统计每个元素的出现次数
all_have_duplicates = all(count > 1 for count in counts.values())  # 检查每个元素的出现次数是否大于1
print(all_have_duplicates)  # 输出：True
```

**解释**：
- `Counter(s)` 创建一个计数器对象，它会统计每个元素在列表中的出现次数。
- 使用 `all()` 检查是否每个元素的出现次数都大于1。

### 链表问题：合并两个已排序的链表
接下来我们来看如何处理链表问题，特别是合并两个已排序的链表。

#### 问题描述
我们需要编写一个函数来合并两个已排序的链表 `s` 和 `t`，并返回一个包含两者所有元素的已排序新链表。该函数需要递归地比较两个链表的首元素，确保合并后的链表是有序的。

#### 链表类定义
首先，定义一个链表类 `Link`，其中每个链表节点包含两个属性：`first` 和 `rest`。

**链表类代码实现：**
```python
class Link:
    empty = ()  # 表示空链表
    
    def __init__(self, first, rest=empty):
        self.first = first  # 当前节点的值
        self.rest = rest    # 下一个节点
```

#### 递归实现合并链表
我们可以通过递归的方式合并两个已排序的链表：
1. 如果链表 `s` 是空链表，则返回链表 `t`。
2. 如果链表 `t` 是空链表，则返回链表 `s`。
3. 比较 `s` 和 `t` 的首元素，选择较小的作为合并后链表的首节点，然后递归地合并剩下的部分。

**递归合并代码实现：**
```python
def merge(s, t):
    if s is Link.empty:
        return t
    if t is Link.empty:
        return s
    if s.first <= t.first:
        return Link(s.first, merge(s.rest, t))  # s 的首元素较小，合并后链表从 s.first 开始
    else:
        return Link(t.first, merge(s, t.rest))  # t 的首元素较小，合并后链表从 t.first 开始
```

#### 解释：
- 如果 `s` 或 `t` 是空链表，直接返回另一个链表。
- 比较 `s.first` 和 `t.first`，选择较小的值作为合并后的链表的首节点，然后递归地处理剩余部分。

### 链表排序与处理问题：递归检查有序性
另一个经典问题是检查一个链表是否按某个标准（例如绝对值）从小到大排序。

#### 递归检查链表有序性
我们可以递归地检查链表的相邻元素是否按照给定的规则排序。如果链表中只有一个元素或为空，则它是有序的。否则，递归检查当前元素与下一个元素的大小关系，并递归处理剩余部分。

**代码实现：**
```python
def is_sorted(s, key=lambda x: x):
    if s is Link.empty or s.rest is Link.empty:
        return True  # 空链表或只有一个元素的链表是有序的
    if key(s.first) > key(s.rest.first):
        return False  # 当前元素比下一个元素大，则链表无序
    return is_sorted(s.rest, key)  # 递归检查剩余部分
```

**解释**：
- `key` 函数用于对每个元素应用某种规则（例如取绝对值 `abs`），默认为身份函数 `lambda x: x`。
- 如果当前元素按照规则比下一个元素大，则返回 `False`，否则递归检查剩余部分。

#### 应用示例：
```python
# 创建链表 1 -> 3 -> 4
s = Link(1, Link(3, Link(4)))
print(is_sorted(s))  # 输出：True

# 创建链表 1 -> 4 -> 3
t = Link(1, Link(4, Link(3)))
print(is_sorted(t))  # 输出：False
```

### 总结
- 在处理列表中的元素计数问题时，`collections.Counter` 是一个高效的工具。
- 对于链表问题，递归是解决排序和合并等问题的自然选择。
- 通过键函数 `key`，我们可以灵活地扩展排序检查，处理多种排序规则。







